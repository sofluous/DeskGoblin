<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Desk Goblin Mash</title>
  <style>
    :root{
      --bg:#0f1116;
      --panel:#151a22;
      --text:#d6dde8;
      --muted:#8a94a7;
      --accent:#6ee7ff;
    }
    html,body{
      height:100%; margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden;
    }
    .wrap{
      display:grid;
      grid-template-rows:auto 1fr auto;
      height:100%;
    }
    header,footer{
      padding:12px 14px;
      background:linear-gradient(to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0));
      border-bottom:1px solid rgba(255,255,255,0.06);
    }
    footer{
      border-top:1px solid rgba(255,255,255,0.06);
      border-bottom:none;
      background:linear-gradient(to top, rgba(255,255,255,0.04), rgba(255,255,255,0));
    }
    header b{ color:var(--accent); }
    .sub{ color:var(--muted); font-size:12px; margin-top:4px; }

    .stage{
      position:relative;
      width:100%;
      height:100%;
    }
    #c{
      width:100%;
      height:100%;
      display:block;
      background:
        radial-gradient(1200px 600px at 50% 20%, rgba(255,255,255,0.06), rgba(255,255,255,0.0)),
        radial-gradient(900px 500px at 10% 80%, rgba(110,231,255,0.05), rgba(255,255,255,0.0));
    }

    .hint{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      font-size:12px; color:var(--muted);
    }
    .pill{
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(255,255,255,0.04);
      padding:4px 8px;
      border-radius:999px;
    }

    /* Thought bubble */
    .bubble{
      position:absolute;
      left: clamp(10px, 3vw, 28px);
      top:  clamp(10px, 2.4vh, 22px);
      width: min(520px, 56vw);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 18px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.30);
      backdrop-filter: blur(6px);
      overflow:hidden;
    }
    .bubble:after{
      content:"";
      position:absolute;
      left: 44px;
      bottom: -14px;
      width: 28px;
      height: 28px;
      background: rgba(255,255,255,0.06);
      border-left: 1px solid rgba(255,255,255,0.10);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      transform: rotate(45deg);
    }
    .bubble textarea{
      width:100%;
      height:96px;
      resize:none;
      border:0;
      outline:none;
      padding:12px 12px 14px 12px;
      background:transparent;
      color: var(--text);
      font-size:14px;
      line-height:1.35;
    }
    .bubble .label{
      padding:8px 12px 0 12px;
      font-size:12px;
      color: rgba(255,255,255,0.35);
    }
  </style>
</head>

<body>
<div class="wrap">
  <header>
    <div><b>Desk Goblin Mash</b> — press keys / click mouse</div>
    <div class="sub">Single HTML file. Keyboard is mirrored for the character. Hold keys to keep them pressed.</div>
  </header>

  <div class="stage">
    <canvas id="c"></canvas>

    <div class="bubble">
      <div class="label">Thought bubble</div>
      <textarea id="thought" placeholder="Type your thoughts… (the goblin will mash the keys while you type)"></textarea>
    </div>
  </div>

  <footer class="hint">
    <span class="pill">Keyboard: press / hold</span>
    <span class="pill">Mouse: left / right / middle</span>
    <span class="pill">Tip: click canvas once if keys don’t register</span>
    <span class="pill">Audio: first click unlocks sound</span>
  </footer>
</div>

<script>
(() => {
  // =========================
  // 1) CANVAS SETUP
  // =========================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const { clientWidth:w, clientHeight:h } = canvas;
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);

  // Focus handling
  canvas.tabIndex = 0;
  canvas.style.outline = "none";
  canvas.addEventListener("pointerdown", () => canvas.focus());

  // =========================
  // 2) HELPERS
  // =========================
  const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
  const lerp  = (a,b,t) => a + (b-a)*t;

  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  // smash approach curve
  function smashEase(t){
    if (t < 0.60){
      const x = t / 0.60;
      return easeOutCubic(x);
    } else if (t < 0.78){
      const x = (t - 0.60) / 0.18;
      return lerp(1.0, 1.08, easeOutCubic(x));
    } else {
      const x = (t - 0.78) / 0.22;
      return lerp(1.08, 1.0, easeOutCubic(x));
    }
  }

  function roundRect(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  // =========================
  // 3) AUDIO (WebAudio)
  // =========================
  let audio = null;
  function audioInit(){
    if (audio) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;

    const ctxA = new AC();
    const master = ctxA.createGain();
    master.gain.value = 0.22;
    master.connect(ctxA.destination);

    function env(g, t0, a, d, s){
      g.gain.cancelScheduledValues(t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(a, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(s, t0 + d);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + d + 0.10);
    }

    function clack(){
      const t = ctxA.currentTime;
      const o = ctxA.createOscillator();
      const g = ctxA.createGain();
      o.type = "square";
      o.frequency.setValueAtTime(520, t);
      o.frequency.exponentialRampToValueAtTime(280, t + 0.03);
      env(g, t, 0.7, 0.04, 0.08);
      o.connect(g); g.connect(master);
      o.start(t); o.stop(t + 0.14);
    }

    function thunk(){
      const t = ctxA.currentTime;

      // low "thump"
      const o = ctxA.createOscillator();
      const g = ctxA.createGain();
      o.type = "sine";
      o.frequency.setValueAtTime(140, t);
      o.frequency.exponentialRampToValueAtTime(70, t + 0.06);
      env(g, t, 0.9, 0.08, 0.12);
      o.connect(g); g.connect(master);
      o.start(t); o.stop(t + 0.18);

      // tiny noise snap (optional)
      const bufLen = Math.floor(ctxA.sampleRate * 0.05);
      const buf = ctxA.createBuffer(1, bufLen, ctxA.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<bufLen;i++){
        data[i] = (Math.random()*2-1) * Math.exp(-i/(bufLen*0.25));
      }
      const n = ctxA.createBufferSource();
      const ng = ctxA.createGain();
      n.buffer = buf;
      ng.gain.value = 0.22;
      n.connect(ng); ng.connect(master);
      n.start(t); n.stop(t + 0.06);
    }

    audio = { ctxA, clack, thunk };
  }

  // unlock audio on first pointerdown anywhere
  window.addEventListener("pointerdown", () => {
    audioInit();
    if (audio?.ctxA?.state === "suspended") audio.ctxA.resume();
  }, { once:false });

  // =========================
  // 4) LAYOUT (centered character + keyboard)
  // =========================
  function layout(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const deskTopY = h * 0.56;

    const kbW = w * 0.66;
    const kbH = h * 0.20;
    const kbX = (w - kbW) * 0.50;
    const kbY = deskTopY + h * 0.075;

    const mouseW = w * 0.12;
    const mouseH = h * 0.16;
    const mouseX = kbX + kbW + w * 0.03;
    const mouseY = kbY + kbH * 0.12;

    const headW = w * 0.22;
    const headH = headW * 0.95;
    const headX = w * 0.50 - headW * 0.5;
    const headY = deskTopY - headH * 0.82;

    // arm rests: symmetric, centered under head/keyboard
    const restY = deskTopY + h * 0.035;
    const restL = { x: w * 0.44, y: restY };
    const restR = { x: w * 0.56, y: restY };

    return {
      w,h,deskTopY,
      keyboard:{ x:kbX,y:kbY,w:kbW,h:kbH },
      mouse:{ x:mouseX,y:mouseY,w:mouseW,h:mouseH },
      head:{ x:headX,y:headY,w:headW,h:headH },
      restL,restR
    };
  }

  // =========================
  // 5) KEYBOARD RECTS (mirrored)
  // =========================
  function buildKeyRects(kb){
    const keys = [];

    // 5 rows: 4 main + a dedicated space row to avoid overlap
    const rows = [
      { y: 0.14, h: 0.20, items: [["ESC",1.2],["1",1],["2",1],["3",1],["4",1],["5",1],["6",1],["7",1],["8",1],["9",1],["0",1],["-",1],["=",1],["BKSP",1.8]] },
      { y: 0.36, h: 0.20, items: [["TAB",1.4],["Q",1],["W",1],["E",1],["R",1],["T",1],["Y",1],["U",1],["I",1],["O",1],["P",1],["[",1],["]",1],["\\",1.3]] },
      { y: 0.58, h: 0.20, items: [["CAPS",1.6],["A",1],["S",1],["D",1],["F",1],["G",1],["H",1],["J",1],["K",1],["L",1],[";",1],["'",1],["ENTER",2.1]] },
      { y: 0.80, h: 0.20, items: [["SHIFT",2.2],["Z",1],["X",1],["C",1],["V",1],["B",1],["N",1],["M",1],[",",1],[".",1],["/",1],["SHIFT",2.2]] },
      { y: 0.94, h: 0.12, items: [["CTRL",1.2],["ALT",1.2],["SPACE",6.2],["ALT",1.2],["CTRL",1.2]] },
    ];

    const padX = kb.w * 0.04;
    const padY = kb.h * 0.10;
    const innerW = kb.w - padX*2;
    const innerH = kb.h - padY*2;

    rows.forEach((row, rIdx) => {
      const totalUnits = row.items.reduce((s,it)=>s+it[1],0);
      const gap = innerW * 0.010;
      const unitW = (innerW - gap*(row.items.length-1)) / totalUnits;

      let x = kb.x + padX;
      const y = kb.y + padY + innerH*row.y - (innerH*row.h)*0.5;
      const h = innerH * row.h;

      row.items.forEach(([label,units], i) => {
        const w = unitW * units;
        keys.push({
          id: `r${rIdx}_${i}_${label}`,
          label,
          x, y, w, h,
          held:false,
          press:0
        });
        x += w + gap;
      });
    });

    // MIRROR for character orientation:
    // x' = kb.x + kb.w - (x - kb.x) - w
    keys.forEach(k => {
      k.x = kb.x + kb.w - (k.x - kb.x) - k.w;
    });

    return keys;
  }

  // Map KeyboardEvent.code -> our label
  function labelFromCode(e){
    const c = e.code;

    // letters
    if (c.startsWith("Key")) return c.slice(3).toUpperCase();

    // digits top row
    if (c.startsWith("Digit")) return c.slice(5);

    // space / enter / etc
    const map = {
      Space: "SPACE",
      Enter: "ENTER",
      Backspace: "BKSP",
      Tab: "TAB",
      Escape: "ESC",
      CapsLock: "CAPS",
      ShiftLeft: "SHIFT",
      ShiftRight:"SHIFT",
      ControlLeft:"CTRL",
      ControlRight:"CTRL",
      AltLeft:"ALT",
      AltRight:"ALT",
      Minus:"-",
      Equal:"=",
      BracketLeft:"[",
      BracketRight:"]",
      Backslash:"\\",
      Semicolon:";",
      Quote:"'",
      Comma:",",
      Period:".",
      Slash:"/"
    };
    if (map[c]) return map[c];

    // arrows: map to WASD for comedy + readability
    const arrows = {
      ArrowUp: "W",
      ArrowDown: "S",
      ArrowLeft: "A",
      ArrowRight: "D"
    };
    if (arrows[c]) return arrows[c];

    return null;
  }

  function findKeyByLabel(keys, label){
    // SHIFT/CTRL/ALT duplicates exist: pick closest to center
    const matches = keys.filter(k => k.label === label);
    if (!matches.length) return null;
    if (matches.length === 1) return matches[0];
    // pick middle-most
    matches.sort((a,b)=>(Math.abs((a.x+a.w*0.5)-keyCenterX) - Math.abs((b.x+b.w*0.5)-keyCenterX)));
    return matches[0];
  }

  // =========================
  // 6) MOUSE TARGETS + STATE
  // =========================
  function mouseTargets(m){
    const {x,y,w,h} = m;
    const r = Math.min(w,h);
    return {
      left:   { id:"mouse_left",  x:x+w*0.30, y:y+h*0.32, r:r*0.12, held:false, press:0 },
      right:  { id:"mouse_right", x:x+w*0.70, y:y+h*0.32, r:r*0.12, held:false, press:0 },
      middle: { id:"mouse_mid",   x:x+w*0.50, y:y+h*0.30, r:r*0.10, held:false, press:0 },
    };
  }

  // =========================
  // 7) ARMS: can hold on pressed target
  // =========================
  function makeArm(origin){
    return {
      origin: { ...origin },
      pos:    { ...origin },
      target: { ...origin },
      assignedId: null,
      phase: "idle", // idle | go | hold | return
      t: 0,
      dur: 0.16,
      holdImpact: 0,
      impact: 0,
      returningFrom: null
    };
  }

  // =========================
  // 8) WORLD STATE
  // =========================
  let keyRects = [];
  let L, R;
  let mTargets = null;

  // pressed targets map: id -> { id, x,y, type, held }
  // id is keyRect.id or mouse target id
  const pressed = new Map();

  let headBob = { y:0, v:0 }; // simple spring for comedic bob

  let lastTime = performance.now();
  let keyCenterX = 0;

  // =========================
  // 9) ASSIGNMENT LOGIC (two hands)
  // =========================
  function assignTargets(){
    const active = Array.from(pressed.values()).filter(t => t.held);

    // maintain existing assignments if still held
    [L,R].forEach(arm => {
      if (arm.assignedId){
        const t = pressed.get(arm.assignedId);
        if (!t || !t.held){
          arm.assignedId = null;
        }
      }
    });

    // gather free targets
    const taken = new Set([L.assignedId, R.assignedId].filter(Boolean));
    const freeTargets = active.filter(t => !taken.has(t.id));

    // assign to arms that are free
    const arms = [L,R].filter(a => !a.assignedId);

    // greedy: for each free arm, pick nearest free target
    arms.forEach(arm => {
      if (!freeTargets.length) return;
      let bestIdx = 0;
      let bestD = Infinity;
      for (let i=0;i<freeTargets.length;i++){
        const t = freeTargets[i];
        const d = Math.hypot(t.x - arm.origin.x, t.y - arm.origin.y);
        if (d < bestD){ bestD = d; bestIdx = i; }
      }
      const chosen = freeTargets.splice(bestIdx,1)[0];
      arm.assignedId = chosen.id;
      startSmash(arm, chosen);
    });

    // if both arms free but only one key held, only one arm should take it
    // (handled naturally by above)
  }

  function startSmash(arm, target){
    arm.target = { x: target.x, y: target.y };
    arm.t = 0;
    arm.phase = "go";
    arm.impact = 0;
    arm.holdImpact = 0;
    if (audio) audio.clack(); // initial "clack" when the goblin reacts
  }

  // =========================
  // 10) INPUT (no rapid trigger, hold keeps depressed)
  // =========================
  const thought = document.getElementById("thought");

  function isTyping(){
    return document.activeElement === thought;
  }

  window.addEventListener("keydown", (e) => {
    // ignore auto-repeat: prevents rapid re-trigger
    if (e.repeat) return;

    // If not typing in textarea, prevent page movement on some keys
    if (!isTyping()){
      if (["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
    }

    const label = labelFromCode(e);
    if (!label) return;

    const key = keyRects.find(k => k.label === label) || null;
    if (!key) return;

    key.held = true;
    pressed.set(key.id, { id:key.id, x:key.x+key.w*0.5, y:key.y+key.h*0.55, type:"key", held:true });

    // update assignment (so both arms can react)
    assignTargets();
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    const label = labelFromCode(e);
    if (!label) return;

    // release all keys that match label? (SHIFT/CTRL/ALT duplicates)
    // We'll release any held keys of that label (simple, reliable).
    keyRects.forEach(k => {
      if (k.label === label){
        k.held = false;
        const t = pressed.get(k.id);
        if (t) t.held = false;
      }
    });

    assignTargets();
  });

  window.addEventListener("mousedown", (e) => {
    const LAYOUT = layout();
    mTargets = mouseTargets(LAYOUT.mouse);

    let t = null;
    if (e.button === 0) t = mTargets.left;
    if (e.button === 1) t = mTargets.middle;
    if (e.button === 2) t = mTargets.right;
    if (!t) return;

    t.held = true;
    pressed.set(t.id, { id:t.id, x:t.x, y:t.y, type:"mouse", held:true });

    assignTargets();
  });

  window.addEventListener("mouseup", (e) => {
    if (!mTargets) return;
    let id = null;
    if (e.button === 0) id = "mouse_left";
    if (e.button === 1) id = "mouse_mid";
    if (e.button === 2) id = "mouse_right";
    if (!id) return;

    const t = pressed.get(id);
    if (t) t.held = false;

    if (id === "mouse_left")  mTargets.left.held = false;
    if (id === "mouse_mid")   mTargets.middle.held = false;
    if (id === "mouse_right") mTargets.right.held = false;

    assignTargets();
  });

  window.addEventListener("contextmenu", (e) => e.preventDefault());

  // =========================
  // 11) DRAW (placeholders; swap with images later)
  // =========================
  function drawDesk(LAYOUT){
    const { w,h,deskTopY } = LAYOUT;
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0, deskTopY, w, h-deskTopY);
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fillRect(0, deskTopY-3, w, 3);
  }

  function drawHead(LAYOUT){
    const { head, w } = LAYOUT;

    // comedic bob/squash: translate by headBob.y, squash slightly on impact
    const squash = 1 - headBob.y * 0.002; // tiny
    const stretch = 1 + headBob.y * 0.001;

    ctx.save();
    ctx.translate(head.x + head.w/2, head.y + head.h/2 + headBob.y);
    ctx.scale(stretch, squash);
    ctx.translate(-head.w/2, -head.h/2);

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    roundRect(0,0, head.w, head.h, head.w*0.35);
    ctx.fill();

    // eyes
    ctx.fillStyle = "rgba(255,255,255,0.45)";
    ctx.beginPath();
    ctx.ellipse(head.w*0.32, head.h*0.52, head.w*0.07, head.h*0.10, 0, 0, Math.PI*2);
    ctx.ellipse(head.w*0.68, head.h*0.52, head.w*0.07, head.h*0.10, 0, 0, Math.PI*2);
    ctx.fill();

    // blush
    ctx.fillStyle = "rgba(255,120,160,0.25)";
    ctx.beginPath();
    ctx.ellipse(head.w*0.22, head.h*0.65, head.w*0.08, head.h*0.04, 0, 0, Math.PI*2);
    ctx.ellipse(head.w*0.78, head.h*0.65, head.w*0.08, head.h*0.04, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawKeyboard(LAYOUT){
    const kb = LAYOUT.keyboard;

    // base
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(kb.x, kb.y, kb.w, kb.h, kb.h*0.16);
    ctx.fill();

    // keys
    keyRects.forEach(k => {
      const press = clamp(k.press, 0, 1);
      const dy = press * (k.h * 0.18);

      ctx.fillStyle = "rgba(255,255,255,0.07)";
      roundRect(k.x, k.y + dy, k.w, k.h, k.h*0.25);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.font = `${Math.max(10, kb.h*0.10)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(k.label, k.x + k.w/2, k.y + dy + k.h/2);
    });
  }

  function drawMouse(LAYOUT){
    const m = LAYOUT.mouse;
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(m.x, m.y, m.w, m.h, m.w*0.45);
    ctx.fill();

    const t = mTargets || mouseTargets(m);

    function drawBtn(btn){
      const dy = clamp(btn.press,0,1) * (btn.r * 0.55);
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.beginPath();
      ctx.ellipse(btn.x, btn.y + dy, btn.r*1.25, btn.r, 0, 0, Math.PI*2);
      ctx.fill();
    }

    drawBtn(t.left);
    drawBtn(t.right);

    // middle wheel
    const dy = clamp(t.middle.press,0,1) * (t.middle.r * 0.55);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.beginPath();
    ctx.ellipse(t.middle.x, t.middle.y + dy, t.middle.r*0.8, t.middle.r*1.2, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function drawArm(arm){
    const ox=arm.origin.x, oy=arm.origin.y;
    const px=arm.pos.x, py=arm.pos.y;

    const dx = px-ox, dy = py-oy;
    const dist = Math.hypot(dx,dy) || 1;
    const nx=dx/dist, ny=dy/dist;

    const th = 10 + arm.impact*8;

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = th;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(ox,oy);
    ctx.lineTo(px - nx*10, py - ny*10);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.beginPath();
    ctx.ellipse(px, py, 18 + arm.impact*6, 14 - arm.impact*3, Math.atan2(dy,dx), 0, Math.PI*2);
    ctx.fill();

    // tiny impact spark
    if (arm.impact > 0.65){
      ctx.strokeStyle = "rgba(110,231,255,0.28)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px + 8, py - 10);
      ctx.lineTo(px + 18, py - 18);
      ctx.moveTo(px - 6, py - 12);
      ctx.lineTo(px - 14, py - 22);
      ctx.stroke();
    }
  }

  // =========================
  // 12) UPDATE LOOP
  // =========================
  function update(dt){
    // key press depth: held stays down, released decays smoothly
    keyRects.forEach(k => {
      const target = k.held ? 1 : 0;
      const speed = k.held ? 18 : 9;
      k.press = lerp(k.press, target, 1 - Math.pow(0.001, dt*speed));
    });

    // mouse press depth
    if (mTargets){
      [mTargets.left, mTargets.right, mTargets.middle].forEach(btn => {
        const target = btn.held ? 1 : 0;
        const speed = btn.held ? 18 : 9;
        btn.press = lerp(btn.press, target, 1 - Math.pow(0.001, dt*speed));
      });
    }

    // Assignments might change if targets released/pressed
    assignTargets();

    // arms
    [L,R].forEach(arm => {
      const assigned = arm.assignedId ? pressed.get(arm.assignedId) : null;
      const isHeld = !!(assigned && assigned.held);

      // if assigned but target moved (it won't), update target point anyway
      if (assigned){
        arm.target.x = assigned.x;
        arm.target.y = assigned.y;
      }

      if (arm.phase === "idle"){
        arm.impact = Math.max(0, arm.impact - dt*8);
        // if has assignment, start smash
        if (arm.assignedId && isHeld){
          startSmash(arm, assigned);
        } else {
          // drift to origin
          arm.pos.x = lerp(arm.pos.x, arm.origin.x, 1 - Math.pow(0.001, dt));
          arm.pos.y = lerp(arm.pos.y, arm.origin.y, 1 - Math.pow(0.001, dt));
        }
        return;
      }

      if (arm.phase === "go"){
        arm.t += dt;
        const t = clamp(arm.t / arm.dur, 0, 1);
        const s = smashEase(t);

        arm.pos.x = lerp(arm.origin.x, arm.target.x, s);
        arm.pos.y = lerp(arm.origin.y, arm.target.y, s);

        arm.impact = Math.max(arm.impact, t);

        if (t >= 1){
          // impact!
          arm.phase = "hold";
          arm.t = 0;
          arm.impact = 1;
          arm.holdImpact = 1;

          // head bob impulse
          headBob.v += 180;

          // thunk sound on impact (only when we actually hit)
          if (audio) audio.thunk();
        }
        return;
      }

      if (arm.phase === "hold"){
        // stay planted if still held, otherwise return
        // soften impact while holding so it doesn't stay "sparked"
        arm.holdImpact = Math.max(0, arm.holdImpact - dt*6);
        arm.impact = Math.max(0.20, arm.holdImpact);

        // keep hand locked on target while held
        arm.pos.x = lerp(arm.pos.x, arm.target.x, 1 - Math.pow(0.001, dt*30));
        arm.pos.y = lerp(arm.pos.y, arm.target.y, 1 - Math.pow(0.001, dt*30));

        if (!isHeld){
          arm.phase = "return";
          arm.t = 0;
        }
        return;
      }

      if (arm.phase === "return"){
        arm.t += dt;
        const t = clamp(arm.t / 0.20, 0, 1);
        const s = easeOutCubic(t);

        arm.pos.x = lerp(arm.target.x, arm.origin.x, s);
        arm.pos.y = lerp(arm.target.y, arm.origin.y, s);

        arm.impact = Math.max(0, 1 - t*1.2);

        if (t >= 1){
          arm.phase = "idle";
          arm.impact = 0;
          arm.pos.x = arm.origin.x;
          arm.pos.y = arm.origin.y;
        }
        return;
      }
    });

    // head bob spring
    // (simple damped spring)
    headBob.v += (-headBob.y * 28) * dt;
    headBob.v *= Math.pow(0.01, dt); // damping
    headBob.y += headBob.v * dt;
    headBob.y = clamp(headBob.y, -18, 18);
  }

  function draw(){
    const LAYOUT = layout();
    const { w,h } = LAYOUT;

    // update derived center for label picking
    keyCenterX = LAYOUT.keyboard.x + LAYOUT.keyboard.w * 0.5;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.fillRect(0,0,w,h);

    // layers
    drawHead(LAYOUT);
    drawDesk(LAYOUT);
    drawKeyboard(LAYOUT);
    drawMouse(LAYOUT);
    drawArm(L);
    drawArm(R);
  }

  function loop(now){
    const dt = Math.min(0.033, (now - lastTime)/1000);
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // =========================
  // 13) INIT
  // =========================
  function init(){
    resize();
    const LAYOUT = layout();
    keyRects = buildKeyRects(LAYOUT.keyboard);
    mTargets = mouseTargets(LAYOUT.mouse);

    L = makeArm(LAYOUT.restL);
    R = makeArm(LAYOUT.restR);

    window.addEventListener("resize", () => {
      const L2 = layout();
      keyRects = buildKeyRects(L2.keyboard);
      mTargets = mouseTargets(L2.mouse);

      L.origin = { ...L2.restL };
      R.origin = { ...L2.restR };

      // if idle, snap
      if (L.phase === "idle"){ L.pos = { ...L.origin }; }
      if (R.phase === "idle"){ R.pos = { ...R.origin }; }
    });

    requestAnimationFrame((t)=>{ lastTime=t; loop(t); });
  }

  init();
})();
</script>
</body>
</html>
