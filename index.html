<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Desk Goblin Mash</title>
    <style>
        :root {
            --bg: #0f1116;
            --text: #d6dde8;
            --muted: #8a94a7;
            --accent: #6ee7ff;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            overflow: hidden;
        }

        select,
        input,
        textarea,
        button {
            color-scheme: dark;
        }

        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(110, 231, 255, 0.38) rgba(255, 255, 255, 0.06);
        }

        *::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        *::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        *::-webkit-scrollbar-thumb {
            background: rgba(110, 231, 255, 0.35);
            border-radius: 8px;
            border: 2px solid rgba(15, 17, 22, 0.9);
        }

        .wrap {
            height: 100%;
        }

        header,
        footer {
            padding: 12px 14px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0));
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        footer {
            border-top: 1px solid rgba(255, 255, 255, 0.06);
            border-bottom: none;
            background: linear-gradient(to top, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0));
        }

        header b {
            color: var(--accent);
        }

        .sub {
            color: var(--muted);
            font-size: 12px;
            margin-top: 4px;
        }

        .stage {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            --sidebar-size: 52px;
            --panel-slot: min(420px, 36vw);
            --panel-mobile-size: clamp(240px, 42vh, 460px);
            --canvas-left: 0px;
            --canvas-right: var(--sidebar-size);
            --canvas-bottom: 0px;
            background:
                radial-gradient(1200px 600px at 50% 20%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.0)),
                radial-gradient(900px 500px at 10% 80%, rgba(110, 231, 255, 0.05), rgba(255, 255, 255, 0.0));
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
            background:
                radial-gradient(1200px 600px at 50% 20%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.0)),
                radial-gradient(900px 500px at 10% 80%, rgba(110, 231, 255, 0.05), rgba(255, 255, 255, 0.0));
        }

        .hint {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            font-size: 12px;
            color: var(--muted);
        }

        .pill {
            border: 1px solid rgba(255, 255, 255, 0.10);
            background: rgba(255, 255, 255, 0.04);
            padding: 4px 8px;
            border-radius: 999px;
        }

        .canvas-host {
            min-width: 0;
            min-height: 0;
        }

        .sidebar-nav {
            width: var(--sidebar-size);
            border-left: 1px solid rgba(255, 255, 255, 0.08);
            border-right: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(8, 12, 20, 0.75);
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 10px 8px;
            box-sizing: border-box;
        }

        .nav-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .nav-group.meta {
            margin-top: auto;
        }

        .nav-btn {
            width: 34px;
            height: 34px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            font-size: 16px;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .nav-btn.active {
            border-color: rgba(110, 231, 255, 0.55);
            color: #dff9ff;
            background: rgba(110, 231, 255, 0.12);
        }

        .side-panel {
            min-width: 290px;
            width: var(--panel-slot);
            max-width: 52vw;
            background: rgba(8, 12, 20, 0.88);
            border-left: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 180ms ease, opacity 180ms ease;
            transform: translateX(0);
            opacity: 1;
        }

        .side-panel.collapsed {
            pointer-events: none;
        }

        .panel-head {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.10);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--muted);
        }

        .panel-title {
            flex: 1;
            text-align: center;
        }

        .panel-head.collapse-left .panel-title {
            order: 2;
        }

        .panel-head.collapse-left #panelCollapseBtn {
            order: 1;
        }

        .panel-head.collapse-right .panel-title {
            order: 1;
        }

        .panel-head.collapse-right #panelCollapseBtn {
            order: 2;
            margin-left: auto;
        }

        #panelCollapseBtn {
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            border-radius: 8px;
            width: 28px;
            height: 28px;
            font-size: 14px;
            cursor: pointer;
        }

        .tab-body {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            padding: 10px;
        }

        .tab-pane {
            display: none;
            height: 100%;
            min-height: 0;
            overflow: auto;
        }

        .tab-pane.active {
            display: flex;
            flex-direction: column;
        }

        .pane-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.45);
            margin-bottom: 8px;
        }

        .panel-textarea {
            width: 100%;
            min-height: 0;
            height: auto;
            flex: 1;
            resize: none;
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 10px;
            outline: none;
            padding: 10px;
            background: rgba(255, 255, 255, 0.04);
            color: var(--text);
            font-size: 14px;
            line-height: 1.35;
            box-sizing: border-box;
        }

        .panel-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 12px;
            color: var(--muted);
        }

        .panel-row select {
            background: rgba(255, 255, 255, 0.09);
            background-color: rgba(255, 255, 255, 0.09);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.20);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            outline: none;
            max-width: 230px;
            appearance: none;
            padding-right: 26px;
            background-image:
                linear-gradient(45deg, transparent 50%, rgba(214, 221, 232, 0.8) 50%),
                linear-gradient(135deg, rgba(214, 221, 232, 0.8) 50%, transparent 50%);
            background-position:
                calc(100% - 15px) calc(50% - 2px),
                calc(100% - 10px) calc(50% - 2px);
            background-size: 5px 5px, 5px 5px;
            background-repeat: no-repeat;
        }

        .panel-row button {
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        #debugText {
            margin: 0;
            margin-top: 8px;
            flex: 1;
            min-height: 0;
            overflow: auto;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.10);
            background: rgba(255, 255, 255, 0.04);
            color: #b9c6dd;
            font: 11px/1.3 Consolas, Menlo, monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .inspector {
            margin-top: 8px;
            min-height: 0;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.03);
        }

        .inspector h4 {
            margin: 0;
            font-size: 12px;
            color: #d7e2f5;
            font-weight: 600;
        }

        .inspector-head {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .inspector-head button {
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .inspector-head .spacer {
            flex: 1;
        }

        .selected-part {
            margin-left: 6px;
            color: var(--muted);
            font-weight: 400;
        }

        .inspector-tabbar {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .inspector-tabbtn {
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: var(--text);
            background: rgba(255, 255, 255, 0.06);
            cursor: pointer;
        }

        .inspector-tabbtn.active {
            border-color: rgba(110, 231, 255, 0.55);
            background: rgba(110, 231, 255, 0.12);
            color: #dff9ff;
        }

        .inspector-pane {
            display: none;
            min-height: 0;
        }

        .inspector-pane.active {
            display: block;
        }

        .inspector-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .slider-list {
            display: grid;
            gap: 8px;
            margin-bottom: 8px;
        }

        .slider-row {
            display: grid;
            grid-template-columns: 26px 1fr 42px;
            gap: 8px;
            align-items: center;
            font-size: 12px;
            color: var(--muted);
        }

        .slider-row input[type="range"] {
            width: 100%;
            appearance: none;
            height: 18px;
            background: transparent;
        }

        .slider-row input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.16);
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            margin-top: -5px;
            border-radius: 50%;
            background: #dff9ff;
            border: 1px solid rgba(110, 231, 255, 0.8);
            box-shadow: 0 0 0 2px rgba(110, 231, 255, 0.2);
        }

        .slider-row input[type="range"]::-moz-range-track {
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.16);
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #dff9ff;
            border: 1px solid rgba(110, 231, 255, 0.8);
            box-shadow: 0 0 0 2px rgba(110, 231, 255, 0.2);
        }

        .slider-val {
            text-align: right;
            color: #d7e2f5;
            font: 11px/1.1 Consolas, Menlo, monospace;
        }

        .inspector-grid input,
        .inspector-grid select {
            width: 100%;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 8px;
            padding: 4px 6px;
            font-size: 12px;
            outline: none;
            appearance: none;
        }

        .inspector-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .inspector-actions button {
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        #partJson {
            width: 100%;
            margin-top: 8px;
            min-height: 90px;
            max-height: 160px;
            resize: vertical;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.04);
            color: #c4d3ec;
            font: 11px/1.3 Consolas, Menlo, monospace;
            padding: 8px;
        }

        .editor-layout {
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: 100%;
            overflow: hidden;
            gap: 8px;
        }

        .table-wrap {
            min-height: 0;
            flex: 1;
            overflow: auto;
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.03);
        }

        .layer-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .layer-table th,
        .layer-table td {
            padding: 8px 9px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            text-align: left;
            vertical-align: middle;
        }

        .layer-table th {
            position: sticky;
            top: 0;
            z-index: 1;
            background: rgba(12, 18, 30, 0.96);
            color: #c9d7ef;
            font-weight: 600;
        }

        .layer-table tr.selected {
            background: rgba(110, 231, 255, 0.10);
        }

        .layer-table .col-layer {
            width: 56px;
            color: var(--muted);
            text-align: center;
        }

        .layer-table .col-vis {
            width: 80px;
            text-align: center;
        }

        .map-select,
        .file-input {
            width: 100%;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.08);
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 8px;
            padding: 5px 7px;
            font-size: 12px;
            outline: none;
        }

        .map-select {
            appearance: none;
            padding-right: 24px;
            background-image:
                linear-gradient(45deg, transparent 50%, rgba(214, 221, 232, 0.8) 50%),
                linear-gradient(135deg, rgba(214, 221, 232, 0.8) 50%, transparent 50%);
            background-position:
                calc(100% - 14px) calc(50% - 2px),
                calc(100% - 9px) calc(50% - 2px);
            background-size: 5px 5px, 5px 5px;
            background-repeat: no-repeat;
        }

        .file-input {
            font-family: Consolas, Menlo, monospace;
        }

        select option {
            background: #111827;
            color: #d6dde8;
        }

        .layer-idx {
            display: inline;
        }

        .layer-drag {
            display: none;
            color: #dff9ff;
            letter-spacing: 1px;
        }

        .layer-table tr.draggable:hover .layer-idx {
            display: none;
        }

        .layer-table tr.draggable:hover .layer-drag {
            display: inline;
        }

        @media (hover: none) {
            .layer-idx {
                display: none;
            }

            .layer-drag {
                display: inline;
            }
        }

        .layer-table code {
            font-size: 11px;
            color: #b9c8e2;
        }

        .layer-table tr.draggable {
            cursor: grab;
        }

        .layer-table tr.dragging {
            opacity: 0.45;
            cursor: grabbing;
        }

        .layer-table tr.drop-target {
            outline: 1px dashed rgba(110, 231, 255, 0.75);
            outline-offset: -2px;
        }

        .hint-info {
            margin-left: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 999px;
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #b9d7ff;
            background: rgba(255, 255, 255, 0.06);
            cursor: help;
            position: relative;
        }

        .hint-info .hint-pop {
            display: none;
            position: absolute;
            top: 20px;
            left: 0;
            min-width: 210px;
            max-width: 280px;
            padding: 8px;
            font-size: 11px;
            line-height: 1.25;
            color: #d8e6fa;
            background: rgba(10, 16, 28, 0.96);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 8px;
            z-index: 5;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            text-align: left;
        }

        .hint-info:hover .hint-pop {
            display: block;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 12px;
            color: var(--muted);
        }

        .toggle {
            position: relative;
            display: inline-flex;
            width: 42px;
            height: 24px;
            flex: 0 0 auto;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }

        .toggle-ui {
            position: absolute;
            inset: 0;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.16);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transition: all 140ms ease;
        }

        .toggle-ui::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            transition: transform 140ms ease;
        }

        .toggle input:checked+.toggle-ui {
            background: rgba(110, 231, 255, 0.35);
            border-color: rgba(110, 231, 255, 0.55);
        }

        .toggle input:checked+.toggle-ui::after {
            transform: translateX(18px);
            background: #e9fbff;
        }

        .vis-toggle {
            width: 36px;
            height: 20px;
            margin: 0;
        }

        .vis-toggle .toggle-ui::after {
            width: 14px;
            height: 14px;
            top: 2px;
            left: 2px;
        }

        .vis-toggle input:checked+.toggle-ui::after {
            transform: translateX(16px);
        }

        /* mobile soft keyboard friendliness */
        .stage {
            height: 100vh;
            /* will be overridden by JS via visualViewport */
        }

        .canvas-host {
            position: absolute;
            top: 0;
            left: var(--canvas-left);
            right: var(--canvas-right);
            bottom: var(--canvas-bottom);
            z-index: 1;
        }

        .sidebar-nav {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 40;
        }

        .stage.side-right .sidebar-nav {
            right: 0;
            left: auto;
        }

        .stage.side-left .sidebar-nav {
            left: 0;
            right: auto;
        }

        .side-panel {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 30;
        }

        .stage.side-right .side-panel {
            right: var(--sidebar-size);
        }

        .stage.side-left .side-panel {
            left: var(--sidebar-size);
        }

        .stage.side-right.panel-expanded {
            --canvas-left: 0px;
            --canvas-right: calc(var(--sidebar-size) + var(--panel-slot));
        }

        .stage.side-right.panel-collapsed {
            --canvas-left: 0px;
            --canvas-right: var(--sidebar-size);
        }

        .stage.side-left.panel-expanded {
            --canvas-left: calc(var(--sidebar-size) + var(--panel-slot));
            --canvas-right: 0px;
        }

        .stage.side-left.panel-collapsed {
            --canvas-left: var(--sidebar-size);
            --canvas-right: 0px;
        }

        .stage.side-right.panel-collapsed .side-panel {
            transform: translateX(100%);
            opacity: 0;
        }

        .stage.side-left.panel-collapsed .side-panel {
            transform: translateX(-100%);
            opacity: 0;
        }

        .stage.nav-top .canvas-host {
            top: 0;
            left: 0;
            right: 0;
        }

        .stage.nav-top .sidebar-nav {
            left: 0;
            right: 0;
            bottom: 0;
            width: auto;
            height: var(--sidebar-size);
            border-left: none;
            border-right: none;
            border-bottom: none;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            flex-direction: row;
            justify-content: flex-start;
            padding: 8px 10px;
            overflow-x: auto;
        }

        .stage.nav-top .nav-group {
            flex-direction: row;
            align-items: center;
        }

        .stage.nav-top .nav-group.meta {
            margin-top: 0;
            margin-left: auto;
        }

        .stage.nav-top .side-panel {
            left: 0;
            right: 0;
            top: auto;
            bottom: var(--sidebar-size);
            height: var(--panel-mobile-size);
            min-width: 0;
            width: auto;
            max-width: none;
            min-height: 0;
            border-left: none;
            border-top: 1px solid rgba(255, 255, 255, 0.12);
            border-bottom: none;
            resize: none;
        }

        .stage.nav-top.panel-collapsed .side-panel {
            transform: translateY(100%);
            opacity: 0;
        }

        .stage.nav-top.panel-collapsed {
            --canvas-bottom: var(--sidebar-size);
        }

        .stage.nav-top.panel-expanded {
            --canvas-bottom: calc(var(--sidebar-size) + var(--panel-mobile-size));
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="stage side-left">
            <div class="canvas-host">
                <canvas id="c"></canvas>
            </div>
            <nav class="sidebar-nav" aria-label="Panel tabs">
                <div class="nav-group main">
                    <button type="button" class="nav-btn active" data-tab="info" title="Info" aria-label="Info">‚Ñπ</button>
                    <button type="button" class="nav-btn" data-tab="input" title="Thoughts" aria-label="Thoughts">üìù</button>
                    <button type="button" class="nav-btn" data-tab="editor" title="Goblin Editor" aria-label="Goblin Editor">üß©</button>
                </div>
                <div class="nav-group meta">
                    <button type="button" class="nav-btn" data-tab="debug" title="Debug" aria-label="Debug">üß™</button>
                    <button type="button" class="nav-btn" data-tab="options" title="Options" aria-label="Options">‚öô</button>
                </div>
            </nav>
            <aside id="sidePanel" class="side-panel">
                <div id="panelHead" class="panel-head">
                    <span id="panelTitle" class="panel-title">Info</span>
                    <button id="panelCollapseBtn" type="button" title="Collapse panel" aria-label="Collapse panel">‚Äπ</button>
                </div>
                <div class="tab-body">
                    <section class="tab-pane active" data-pane="info">
                        <div><b>Desk Goblin Mash</b></div>
                        <div class="sub">A browser buddy that adds a little whimsy while you type and click.</div>
                        <div class="sub">Controls: type in the Thoughts tab, hold keys, click mouse buttons, and switch skins in Goblin/Options.</div>
                        <div class="sub">Perspective note: left/right asset naming is model-space (character left/right), not viewer-space.</div>
                    </section>
                    <section class="tab-pane" data-pane="input">
                        <textarea id="thought" class="panel-textarea" placeholder="Type... (the goblin will mash while you type)"></textarea>
                    </section>
                    <section class="tab-pane" data-pane="debug">
                        <label class="toggle-row"><span>Show debug text</span><span class="toggle"><input id="debugEnabled" type="checkbox" checked /><span class="toggle-ui"></span></span></label>
                        <label class="toggle-row"><span>Show skeleton overlay</span><span class="toggle"><input id="skeletonEnabled" type="checkbox" /><span class="toggle-ui"></span></span></label>
                        <label class="toggle-row"><span>Semantic labels (model-space)</span><span class="toggle"><input id="semanticEnabled" type="checkbox" checked /><span class="toggle-ui"></span></span></label>
                        <pre id="debugText">Debug ready...</pre>
                    </section>
                    <section class="tab-pane" data-pane="editor">
                            <div class="editor-layout">
                                <div class="panel-row">
                                    <select id="editorSkinSelect" aria-label="Editor skin"></select>
                                    <button id="partsResetAll" type="button">Reset All Parts</button>
                                </div>
                                <div class="table-wrap">
                                    <table class="layer-table">
                                    <thead>
                                        <tr>
                                            <th class="col-layer">Layer</th>
                                            <th>Part Mapping <span class="hint-info">i<span class="hint-pop">Model left/right is from the character's perspective. Model-left appears on viewer-right.</span></span></th>
                                            <th>File</th>
                                            <th class="col-vis">Show</th>
                                        </tr>
                                    </thead>
                                    <tbody id="layerTableBody"></tbody>
                                </table>
                            </div>
                            <div id="partInspector" class="inspector">
                                <div class="inspector-head">
                                    <h4>Part Properties <span id="selectedPartLabel" class="selected-part"></span></h4>
                                    <span class="spacer"></span>
                                    <button id="partReset" type="button">Reset Part</button>
                                </div>
                                <div class="inspector-tabbar">
                                    <button id="inspectorTabInputs" class="inspector-tabbtn active" type="button">Inputs</button>
                                    <button id="inspectorTabJson" class="inspector-tabbtn" type="button">JSON</button>
                                </div>
                                <div id="inspectorPaneInputs" class="inspector-pane active">
                                    <div class="slider-list">
                                        <label class="slider-row">dX
                                            <input id="partDx" type="range" min="-220" max="220" step="1" value="0" />
                                            <span id="partDxVal" class="slider-val">0</span>
                                        </label>
                                        <label class="slider-row">dY
                                            <input id="partDy" type="range" min="-220" max="220" step="1" value="0" />
                                            <span id="partDyVal" class="slider-val">0</span>
                                        </label>
                                        <label class="slider-row">sX%
                                            <input id="partDw" type="range" min="-95" max="300" step="1" value="0" />
                                            <span id="partDwVal" class="slider-val">0</span>
                                        </label>
                                        <label class="slider-row">sY%
                                            <input id="partDh" type="range" min="-95" max="300" step="1" value="0" />
                                            <span id="partDhVal" class="slider-val">0</span>
                                        </label>
                                    </div>
                                    <label class="toggle-row"><span>Lock aspect</span><span class="toggle"><input id="aspectLockEnabled" type="checkbox" checked /><span class="toggle-ui"></span></span></label>
                                </div>
                                <div id="inspectorPaneJson" class="inspector-pane">
                                    <div class="inspector-actions">
                                        <button id="partCopyJson" type="button">Copy JSON</button>
                                    </div>
                                    <textarea id="partJson" readonly></textarea>
                                </div>
                            </div>
                        </div>
                    </section>
                    <section class="tab-pane" data-pane="options">
                        <div class="panel-row">
                            <label for="panelSide">Panel Side:</label>
                            <select id="panelSide">
                                <option value="right">Right</option>
                                <option value="left" selected>Left</option>
                            </select>
                        </div>
                        <div class="panel-row">
                            <label for="charSelect">Character:</label>
                            <select id="charSelect"></select>
                        </div>
                    </section>
                </div>
            </aside>
        </div>

    </div>

    <script>
        (() => {
            const canvas = document.getElementById("c");
            const ctx = canvas.getContext("2d");
            const thought = document.getElementById("thought");
            const charSelect = document.getElementById("charSelect");
            const editorSkinSelect = document.getElementById("editorSkinSelect");
            const panelSideEl = document.getElementById("panelSide");
            const panelHead = document.getElementById("panelHead");
            const panelCollapseBtn = document.getElementById("panelCollapseBtn");
            const panelTitle = document.getElementById("panelTitle");
            const sidePanel = document.getElementById("sidePanel");
            const debugEnabled = document.getElementById("debugEnabled");
            const skeletonEnabled = document.getElementById("skeletonEnabled");
            const semanticEnabled = document.getElementById("semanticEnabled");
            const aspectLockEnabled = document.getElementById("aspectLockEnabled");
            const debugText = document.getElementById("debugText");
            const tabButtons = Array.from(document.querySelectorAll(".nav-btn"));
            const tabPanes = Array.from(document.querySelectorAll(".tab-pane"));
            const partInspector = document.getElementById("partInspector");
            const selectedPartLabelEl = document.getElementById("selectedPartLabel");
            const inspectorTabInputs = document.getElementById("inspectorTabInputs");
            const inspectorTabJson = document.getElementById("inspectorTabJson");
            const inspectorPaneInputs = document.getElementById("inspectorPaneInputs");
            const inspectorPaneJson = document.getElementById("inspectorPaneJson");
            const partDxEl = document.getElementById("partDx");
            const partDyEl = document.getElementById("partDy");
            const partDwEl = document.getElementById("partDw");
            const partDhEl = document.getElementById("partDh");
            const partDxValEl = document.getElementById("partDxVal");
            const partDyValEl = document.getElementById("partDyVal");
            const partDwValEl = document.getElementById("partDwVal");
            const partDhValEl = document.getElementById("partDhVal");
            const partResetEl = document.getElementById("partReset");
            const partsResetAllEl = document.getElementById("partsResetAll");
            const partCopyJsonEl = document.getElementById("partCopyJson");
            const partJsonEl = document.getElementById("partJson");
            const layerTableBody = document.getElementById("layerTableBody");

            const DESIGN = { w: 1000, h: 700 };
            let VIEW = { w: 1000, h: 700, scale: 1, ox: 0, oy: 0 };

            function resize() {
                const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

                // canvas CSS size comes from the stage
                const cssW = canvas.clientWidth;
                const cssH = canvas.clientHeight;

                canvas.width = Math.floor(cssW * dpr);
                canvas.height = Math.floor(cssH * dpr);

                // compute scene transform in CSS pixels (then dpr handled by setTransform)
                const scale = Math.min(cssW / DESIGN.w, cssH / DESIGN.h);
                const ox = (cssW - DESIGN.w * scale) * 0.5;
                const oy = (cssH - DESIGN.h * scale) * 0.5;

                VIEW = { w: cssW, h: cssH, scale, ox, oy };

                // include dpr in the transform
                ctx.setTransform(dpr * scale, 0, 0, dpr * scale, dpr * ox, dpr * oy);
            }

            window.addEventListener("resize", resize);

            canvas.tabIndex = 0;
            canvas.style.outline = "none";
            canvas.addEventListener("pointerdown", () => canvas.focus());

            function isTyping() { return document.activeElement === thought; }
            function updateCollapseAffordance() {
                const collapseToward = panelSide === "left" ? "left" : "right";
                const isCollapsed = !panelOpen;
                panelHead.classList.toggle("collapse-left", panelSide === "right");
                panelHead.classList.toggle("collapse-right", panelSide === "left");

                if (collapseToward === "left") {
                    panelCollapseBtn.textContent = isCollapsed ? "\u2192" : "\u2190";
                } else {
                    panelCollapseBtn.textContent = isCollapsed ? "\u2190" : "\u2192";
                }
                panelCollapseBtn.title = isCollapsed ? "Expand panel" : `Collapse panel ${collapseToward}`;
                panelCollapseBtn.setAttribute("aria-label", panelCollapseBtn.title);
            }

            function setPanelOpen(open) {
                sidePanel.classList.toggle("collapsed", !open);
                stageEl.classList.toggle("panel-collapsed", !open);
                stageEl.classList.toggle("panel-expanded", !!open);
                updateCollapseAffordance();
                resize();
            }

            function setPanelSide(side) {
                const s = (side === "left") ? "left" : "right";
                stageEl.classList.toggle("side-left", s === "left");
                stageEl.classList.toggle("side-right", s === "right");
                panelSideEl.value = s;
                updateCollapseAffordance();
                resize();
            }

            function setActiveTab(tab) {
                tabButtons.forEach((btn) => {
                    const active = !!tab && btn.dataset.tab === tab;
                    btn.classList.toggle("active", active);
                    btn.setAttribute("aria-pressed", active ? "true" : "false");
                });
                tabPanes.forEach((pane) => pane.classList.toggle("active", !!tab && pane.dataset.pane === tab));
                const labelMap = { info: "Info", input: "Thoughts", editor: "Goblin Editor", debug: "Debug", options: "Options" };
                panelTitle.textContent = labelMap[tab] || "Panel";
            }

            function closePanelWithNoTab() {
                panelOpen = false;
                currentTab = null;
                setPanelOpen(false);
                setActiveTab(null);
            }

            function openPanelWithTab(tab) {
                const next = tab || lastTab || "info";
                currentTab = next;
                lastTab = next;
                panelOpen = true;
                setPanelOpen(true);
                setActiveTab(next);
            }

            function updatePanelLayoutMode() {
                const vv = window.visualViewport;
                const w = vv ? vv.width : window.innerWidth;
                const h = vv ? vv.height : window.innerHeight;
                const navTop = w <= 900 && h > w;
                stageEl.classList.toggle("nav-top", navTop);
            }

            let panelOpen = true;
            let debugOn = true;
            let skeletonOn = false;
            let semanticOn = true;
            let aspectLockOn = true;
            let selectedPartKey = "";
            let inspectorPane = "inputs";
            let panelSide = "left";
            let currentTab = "info";
            let lastTab = "info";
            panelCollapseBtn.addEventListener("click", () => {
                if (panelOpen) {
                    closePanelWithNoTab();
                } else {
                    openPanelWithTab(lastTab);
                }
            });
            panelSideEl.addEventListener("change", () => {
                panelSide = panelSideEl.value === "left" ? "left" : "right";
                setPanelSide(panelSide);
            });
            debugEnabled.addEventListener("change", () => {
                debugOn = !!debugEnabled.checked;
                debugText.style.display = debugOn ? "block" : "none";
            });
            skeletonEnabled.addEventListener("change", () => {
                skeletonOn = !!skeletonEnabled.checked;
            });
            semanticEnabled.addEventListener("change", () => {
                semanticOn = !!semanticEnabled.checked;
                refreshPartsInspector();
            });
            aspectLockEnabled.addEventListener("change", () => {
                aspectLockOn = !!aspectLockEnabled.checked;
                if (aspectLockOn) {
                    partDhEl.value = partDwEl.value;
                    const def = getActiveAssetSkinDef();
                    if (def && selectedPartKey) {
                        const st = getInspectorState(def);
                        st.partTweaks[selectedPartKey] = readPartBoxInputs();
                        refreshPartsInspector();
                    }
                }
            });
            tabButtons.forEach((btn) => {
                btn.addEventListener("click", () => {
                    const tab = btn.dataset.tab;
                    if (panelOpen && currentTab === tab) {
                        closePanelWithNoTab();
                        return;
                    }
                    openPanelWithTab(tab);
                });
            });
            function setInspectorPane(name) {
                inspectorPane = (name === "json") ? "json" : "inputs";
                inspectorTabInputs.classList.toggle("active", inspectorPane === "inputs");
                inspectorTabJson.classList.toggle("active", inspectorPane === "json");
                inspectorPaneInputs.classList.toggle("active", inspectorPane === "inputs");
                inspectorPaneJson.classList.toggle("active", inspectorPane === "json");
            }
            inspectorTabInputs.addEventListener("click", () => setInspectorPane("inputs"));
            inspectorTabJson.addEventListener("click", () => setInspectorPane("json"));
            [partDxEl, partDyEl, partDwEl, partDhEl].forEach((el) => {
                el.addEventListener("input", () => {
                    const def = getActiveAssetSkinDef();
                    if (!def || !selectedPartKey) return;
                    if (aspectLockOn && (el === partDwEl || el === partDhEl)) {
                        if (el === partDwEl) partDhEl.value = partDwEl.value;
                        if (el === partDhEl) partDwEl.value = partDhEl.value;
                    }
                    const st = getInspectorState(def);
                    st.partTweaks[selectedPartKey] = readPartBoxInputs();
                    refreshPartsInspector();
                });
            });
            partResetEl.addEventListener("click", () => {
                const def = getActiveAssetSkinDef();
                if (!def || !selectedPartKey) return;
                const st = getInspectorState(def);
                delete st.partTweaks[selectedPartKey];
                refreshPartsInspector();
            });
            partsResetAllEl.addEventListener("click", () => {
                const def = getActiveAssetSkinDef();
                if (!def) return;
                const st = getInspectorState(def);
                const parts = { ...DEFAULT_ASSET_PARTS, ...canonicalizePartMap(def.parts || {}) };
                const keys = Object.keys(parts);
                st.partsMap = { ...parts };
                st.partTweaks = clonePartTweaks(def.partTweaks || {});
                st.visibleSet = new Set(def.visibleParts || DEFAULT_VISIBLE_PARTS);
                st.drawOrder = normalizeLayerOrder(keys, def.drawOrder || keys);
                st.requested = false;
                st.loaded = false;
                st.failed = [];
                st.images = {};
                loadAssetSkin(def);
                refreshPartsInspector();
            });
            partCopyJsonEl.addEventListener("click", async () => {
                try {
                    await navigator.clipboard.writeText(partJsonEl.value || "");
                } catch (_) {
                    partJsonEl.select();
                    document.execCommand("copy");
                    partJsonEl.setSelectionRange(0, 0);
                }
            });

            const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
            const lerp = (a, b, t) => a + (b - a) * t;
            function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
            const copyNumObject = (obj) => Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, +v]));
            const copyColorObject = (obj) => Object.fromEntries(
                Object.entries(obj).map(([k, arr]) => [k, arr.slice()])
            );
            const lerpNumObject = (a, b, t) => {
                const out = {};
                for (const k of Object.keys(b)) out[k] = lerp(a[k], b[k], t);
                return out;
            };
            const lerpColorObject = (a, b, t) => {
                const out = {};
                for (const k of Object.keys(b)) out[k] = b[k].map((v, i) => lerp(a[k][i], v, t));
                return out;
            };
            const rgba = (c) => `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${c[3]})`;
            function smashEase(t) {
                if (t < 0.60) return easeOutCubic(t / 0.60);
                if (t < 0.78) return lerp(1.0, 1.08, easeOutCubic((t - 0.60) / 0.18));
                return lerp(1.08, 1.0, easeOutCubic((t - 0.78) / 0.22));
            }

            const BASE_SKINS = {
                test: {
                    label: "Test Goblin",
                    morph: {
                        round: 0.35,
                        earWidth: 0.17,
                        earHeight: 0.18,
                        eyeGap: 0.18,
                        eyeWidth: 0.07,
                        eyeHeight: 0.10,
                        blushWidth: 0.08,
                        blushHeight: 0.04,
                        mouthWidth: 0.24,
                        mouthHeight: 0.05,
                        mouthY: 0.73,
                        browTilt: 0.08,
                        hornSize: 0.0,
                        squint: 0.30
                    },
                    colors: {
                        skin: [228, 246, 232, 0.12],
                        eye: [248, 252, 255, 0.52],
                        blush: [255, 120, 160, 0.25],
                        brow: [230, 245, 234, 0.42],
                        mouth: [255, 210, 220, 0.30],
                        horn: [255, 255, 255, 0.10]
                    }
                },
                moss: {
                    label: "Moss Goblin",
                    morph: {
                        round: 0.30,
                        earWidth: 0.20,
                        earHeight: 0.24,
                        eyeGap: 0.20,
                        eyeWidth: 0.065,
                        eyeHeight: 0.12,
                        blushWidth: 0.065,
                        blushHeight: 0.032,
                        mouthWidth: 0.20,
                        mouthHeight: 0.06,
                        mouthY: 0.74,
                        browTilt: 0.14,
                        hornSize: 0.04,
                        squint: 0.38
                    },
                    colors: {
                        skin: [132, 197, 146, 0.22],
                        eye: [240, 255, 240, 0.58],
                        blush: [120, 190, 110, 0.30],
                        brow: [80, 120, 88, 0.62],
                        mouth: [248, 220, 184, 0.34],
                        horn: [245, 245, 230, 0.24]
                    }
                },
                neon: {
                    label: "Neon Gremlin",
                    morph: {
                        round: 0.42,
                        earWidth: 0.14,
                        earHeight: 0.14,
                        eyeGap: 0.17,
                        eyeWidth: 0.08,
                        eyeHeight: 0.095,
                        blushWidth: 0.10,
                        blushHeight: 0.045,
                        mouthWidth: 0.26,
                        mouthHeight: 0.042,
                        mouthY: 0.72,
                        browTilt: 0.03,
                        hornSize: 0.09,
                        squint: 0.24
                    },
                    colors: {
                        skin: [175, 110, 245, 0.20],
                        eye: [255, 250, 188, 0.62],
                        blush: [255, 110, 220, 0.32],
                        brow: [255, 224, 140, 0.58],
                        mouth: [255, 240, 190, 0.34],
                        horn: [150, 255, 252, 0.30]
                    }
                }
            };
            let skinLibrary = { ...BASE_SKINS };

            const PART_KEY_ALIASES = {
                charLeftEarFill: ["charLeftEarFill", "leftEarFill"],
                charLeftEarLine: ["charLeftEarLine", "leftEarLine"],
                charLeftEarInner: ["charLeftEarInner", "leftEarInner"],
                charRightEarFill: ["charRightEarFill", "rightEarFill"],
                charRightEarLine: ["charRightEarLine", "rightEarLine"],
                charLeftArmDownFill: ["charLeftArmDownFill", "leftArmDownFill", "leftArmFill"],
                charLeftArmDownLine: ["charLeftArmDownLine", "leftArmDownLine", "leftArmLine", "leftArmLower"],
                charLeftArmUpFill: ["charLeftArmUpFill", "leftArmUpFill"],
                charLeftArmUpLine: ["charLeftArmUpLine", "leftArmUpLine"],
                charRightArmDownFill: ["charRightArmDownFill", "rightArmDownFill", "rightArmFill"],
                charRightArmDownLine: ["charRightArmDownLine", "rightArmDownLine", "rightArmLine"],
                charRightArmUpFill: ["charRightArmUpFill", "rightArmUpFill"],
                charRightArmUpLine: ["charRightArmUpLine", "rightArmUpLine"],
                charLeftEye: ["charLeftEye", "leftEye"],
                charRightEye: ["charRightEye", "rightEye"],
                charLeftBrow: ["charLeftBrow", "leftBrow"],
                charRightBrow: ["charRightBrow", "rightBrow"],
                headFill: ["headFill"],
                headLine: ["headLine"],
                bodyFill: ["bodyFill"],
                bodyLine: ["bodyLine"],
                tailFill: ["tailFill"],
                tailLine: ["tailLine"],
                mouth: ["mouth"]
            };

            const DEFAULT_ASSET_PARTS = {
                bodyFill: "BodyFillParts/Body fill.PNG",
                bodyLine: "BodyFillParts/Body.PNG",
                tailFill: "TailParts/TailFill.PNG",
                tailLine: "TailParts/Tail.PNG",
                headFill: "HeadBase/HeadFill.PNG",
                headLine: "HeadBase/Head.PNG",
                charLeftEarFill: "L_EarParts/L_EarFill.PNG",
                charLeftEarLine: "L_EarParts/L_Ear.PNG",
                charLeftEarInner: "L_EarParts/InnerEarLine.PNG",
                charRightEarFill: "R_EarParts/R_EarFill.PNG",
                charRightEarLine: "R_EarParts/R_Ear.PNG",
                charLeftArmDownFill: "L_ArmDownParts/L_ArmFill.PNG",
                charLeftArmDownLine: "L_ArmDownParts/L_ArmLower.PNG",
                charLeftArmUpFill: "L_ArmUpParts/L_ArmUpFill.PNG",
                charLeftArmUpLine: "L_ArmUpParts/L_ArmUp.PNG",
                charRightArmDownFill: "R_ArmDownParts/R_ArmFill.PNG",
                charRightArmDownLine: "R_ArmDownParts/R_Arm.PNG",
                charRightArmUpFill: "R_ArmDownParts/R_ArmFill.PNG",
                charRightArmUpLine: "R_ArmDownParts/R_Arm.PNG",
                charLeftEye: "Face/L_Eye.PNG",
                charRightEye: "Face/R_Eye.PNG",
                charLeftBrow: "Face/L_Eyebrow.PNG",
                charRightBrow: "Face/R_Eyebrow.PNG",
                mouth: "Face/Mouth.PNG"
            };
            const DEFAULT_VISIBLE_PARTS = [
                "headFill", "headLine",
                "charLeftEye", "charRightEye",
                "charLeftBrow", "charRightBrow",
                "mouth"
            ];
            const assetSkinCache = new Map();

            const stageEl = document.querySelector(".stage");

            function syncToVisualViewport() {
                const vv = window.visualViewport;
                const h = vv ? Math.floor(vv.height) : window.innerHeight;
                stageEl.style.height = h + "px";
                updatePanelLayoutMode();
                // Keep content pinned (prevents weird √¢‚Ç¨≈ìkeyboard pushes page√¢‚Ç¨¬ù behavior)
                window.scrollTo(0, 0);
                resize(); // re-run canvas sizing
            }

            // run now + on changes
            syncToVisualViewport();
            window.addEventListener("resize", syncToVisualViewport);
            if (window.visualViewport) {
                window.visualViewport.addEventListener("resize", syncToVisualViewport);
                window.visualViewport.addEventListener("scroll", syncToVisualViewport);
            }

            // when the thought bubble is focused, force a re-sync
            thought.addEventListener("focus", () => setTimeout(syncToVisualViewport, 50));
            thought.addEventListener("blur", () => setTimeout(syncToVisualViewport, 50));

            function roundRect(x, y, w, h, r) {
                r = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.arcTo(x + w, y, x + w, y + h, r);
                ctx.arcTo(x + w, y + h, x, y + h, r);
                ctx.arcTo(x, y + h, x, y, r);
                ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
            }

            // ===== Audio (unchanged)
            let audio = null;
            function audioInit() {
                if (audio) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                if (!AC) return;
                const a = new AC();
                const master = a.createGain();
                master.gain.value = 0.22;
                master.connect(a.destination);

                function env(g, t0, aPeak, decay, sustain) {
                    g.gain.cancelScheduledValues(t0);
                    g.gain.setValueAtTime(0.0001, t0);
                    g.gain.exponentialRampToValueAtTime(aPeak, t0 + 0.01);
                    g.gain.exponentialRampToValueAtTime(sustain, t0 + decay);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + decay + 0.10);
                }

                function clack() {
                    const t = a.currentTime;
                    const o = a.createOscillator();
                    const g = a.createGain();
                    o.type = "square";
                    o.frequency.setValueAtTime(520, t);
                    o.frequency.exponentialRampToValueAtTime(280, t + 0.03);
                    env(g, t, 0.7, 0.04, 0.08);
                    o.connect(g); g.connect(master);
                    o.start(t); o.stop(t + 0.14);
                }
                function thunk() {
                    const t = a.currentTime;
                    const o = a.createOscillator();
                    const g = a.createGain();
                    o.type = "sine";
                    o.frequency.setValueAtTime(140, t);
                    o.frequency.exponentialRampToValueAtTime(70, t + 0.06);
                    env(g, t, 0.9, 0.08, 0.12);
                    o.connect(g); g.connect(master);
                    o.start(t); o.stop(t + 0.18);

                    const len = Math.floor(a.sampleRate * 0.05);
                    const buf = a.createBuffer(1, len, a.sampleRate);
                    const data = buf.getChannelData(0);
                    for (let i = 0; i < len; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (len * 0.25));
                    }
                    const n = a.createBufferSource();
                    const ng = a.createGain();
                    n.buffer = buf;
                    ng.gain.value = 0.22;
                    n.connect(ng); ng.connect(master);
                    n.start(t); n.stop(t + 0.06);
                }

                audio = { a, clack, thunk };
            }
            window.addEventListener("pointerdown", () => {
                audioInit();
                if (audio?.a?.state === "suspended") audio.a.resume();
            }, { passive: true });

            // ===== Layout
            function layout() {
                const w = DESIGN.w;
                const h = DESIGN.h;

                const deskTopY = h * 0.56;

                // √¢≈ì‚Ä¶ stable keyboard proportions (design space)
                const kbW = w * 0.46;
                const kbH = h * 0.20;
                const kbX = (w - kbW) * 0.50;
                const kbY = deskTopY + h * 0.075;

                // mousepad + mouse: slimmer/taller mouse
                const padW = w * 0.18;
                const padH = h * 0.20;
                // Character is facing viewer, so character-right mouse appears user-left.
                const padX = kbX - w * 0.03 - padW;
                const padY = kbY;

                // make mouse more √¢‚Ç¨≈ìmouse-like√¢‚Ç¨¬ù
                const mouseW = w * 0.075;  // narrower
                const mouseH = h * 0.145;  // taller

                const headW = w * 0.22;
                const headH = headW * 0.95;
                const headX = w * 0.50 - headW * 0.5;
                const headY = deskTopY - headH * 0.82;

                // shoulders at head edges (design space)
                const shoulderY = deskTopY + 2;
                const shoulderL = { x: headX + headW * 0.06, y: shoulderY };
                const shoulderR = { x: headX + headW * 0.94, y: shoulderY };

                const raise = h * 0.075;
                const restL = { x: headX + headW * 0.16, y: deskTopY - raise };
                const restR = { x: headX + headW * 0.84, y: deskTopY - raise };

                return {
                    w, h, deskTopY,
                    keyboard: { x: kbX, y: kbY, w: kbW, h: kbH },
                    mousepad: { x: padX, y: padY, w: padW, h: padH },
                    mouseSize: { w: mouseW, h: mouseH },
                    head: { x: headX, y: headY, w: headW, h: headH },
                    shoulderL, shoulderR,
                    restL, restR
                };
            }

            // ===== Keyboard
            function buildKeyRects(kb) {
                const keys = [];

                const rows = [
                    [["ESC", 1.2], ["1", 1], ["2", 1], ["3", 1], ["4", 1], ["5", 1], ["6", 1], ["7", 1], ["8", 1], ["9", 1], ["0", 1], ["-", 1], ["=", 1], ["BKSP", 1.8]],
                    [["TAB", 1.4], ["Q", 1], ["W", 1], ["E", 1], ["R", 1], ["T", 1], ["Y", 1], ["U", 1], ["I", 1], ["O", 1], ["P", 1], ["[", 1], ["]", 1], ["\\", 1.3]],
                    [["CAPS", 1.6], ["A", 1], ["S", 1], ["D", 1], ["F", 1], ["G", 1], ["H", 1], ["J", 1], ["K", 1], ["L", 1], [";", 1], ["'", 1], ["ENTER", 2.1]],
                    [["SHIFT", 2.2], ["Z", 1], ["X", 1], ["C", 1], ["V", 1], ["B", 1], ["N", 1], ["M", 1], [",", 1], [".", 1], ["/", 1], ["SHIFT", 2.2]],
                    [["CTRL", 1.2], ["ALT", 1.2], ["SPACE", 6.2], ["ALT", 1.2], ["CTRL", 1.2]],
                ];

                const padX = kb.w * 0.04;
                const padY = kb.h * 0.10;
                const innerW = kb.w - padX * 2;
                const innerH = kb.h - padY * 2;

                const gapY = innerH * 0.04;
                const rowH = (innerH - gapY * (rows.length - 1)) / rows.length;

                rows.forEach((items, rIdx) => {
                    const totalUnits = items.reduce((s, it) => s + it[1], 0);

                    const gapX = innerW * 0.010;
                    const unitW = (innerW - gapX * (items.length - 1)) / totalUnits;

                    let x = kb.x + padX;
                    const y = kb.y + padY + rIdx * (rowH + gapY);

                    items.forEach(([label, u], i) => {
                        const w = unitW * u;
                        keys.push({
                            id: `r${rIdx}_${i}_${label}`,
                            label,
                            x, y, w, h: rowH,
                            held: false,
                            press: 0
                        });
                        x += w + gapX;
                    });
                });

                return keys;
            }


            function labelFromCode(e) {
                const c = e.code;
                if (c.startsWith("Key")) return c.slice(3).toUpperCase();
                if (c.startsWith("Digit")) return c.slice(5);
                const map = {
                    Space: "SPACE", Enter: "ENTER", Backspace: "BKSP", Tab: "TAB", Escape: "ESC",
                    CapsLock: "CAPS", ShiftLeft: "SHIFT", ShiftRight: "SHIFT",
                    ControlLeft: "CTRL", ControlRight: "CTRL", AltLeft: "ALT", AltRight: "ALT",
                    Minus: "-", Equal: "=", BracketLeft: "[", BracketRight: "]",
                    Backslash: "\\", Semicolon: ";", Quote: "'", Comma: ",", Period: ".", Slash: "/"
                };
                if (map[c]) return map[c];
                const arrows = { ArrowUp: "W", ArrowDown: "S", ArrowLeft: "A", ArrowRight: "D" };
                if (arrows[c]) return arrows[c];
                return null;
            }

            // ===== Mouse pad clamp + targets
            function clampMouseToPad(mx, my, pad, mouseSize) {
                const minX = pad.x + mouseSize.w * 0.5;
                const maxX = pad.x + pad.w - mouseSize.w * 0.5;
                const minY = pad.y + mouseSize.h * 0.5;
                const maxY = pad.y + pad.h - mouseSize.h * 0.5;
                return { x: clamp(mx, minX, maxX), y: clamp(my, minY, maxY) };
            }

            function mouseTargetsFromCenter(cx, cy, mouseSize) {
                const w = mouseSize.w, h = mouseSize.h;
                const r = Math.min(w, h);
                return {
                    // Character-facing orientation: buttons toward viewer (lower on screen).
                    left: { id: "mouse_left", x: cx - w * 0.18, y: cy + h * 0.10, r: r * 0.12, held: false, press: 0 },
                    right: { id: "mouse_right", x: cx + w * 0.18, y: cy + h * 0.10, r: r * 0.12, held: false, press: 0 },
                    middle: { id: "mouse_mid", x: cx, y: cy + h * 0.12, r: r * 0.10, held: false, press: 0 },
                    move: { id: "mouse_move", x: cx, y: cy, r: r * 0.14, held: false, press: 0 },
                };
            }

            // ===== Arms
            function makeArm(shoulder, restHand) {
                return {
                    shoulder: { ...shoulder },
                    rest: { ...restHand },
                    pos: { ...restHand },
                    target: { ...restHand },
                    assignedId: null,
                    phase: "idle",
                    t: 0,
                    dur: 0.13,
                    impact: 0,
                    holdImpact: 0
                };
            }

            // ===== World state
            let keys = [];
            let armL = null, armR = null;

            const pressed = new Map();

            let mouseCenter = { x: 0, y: 0 };
            let mousePad = null;
            let mouseSize = null;
            let mTargets = null;
            let mouseMoveTimer = 0;

            let headBob = { y: 0, v: 0 };
            let lastTime = performance.now();
            let sceneTime = 0;
            let fpsSmoothed = 60;
            let debugTicker = 0;
            let lastAssetBoxes = [];

            const skinState = {
                activeId: "test",
                targetId: "test",
                t: 1,
                dur: 0.24,
                fromMorph: copyNumObject(BASE_SKINS.test.morph),
                toMorph: copyNumObject(BASE_SKINS.test.morph),
                renderedMorph: copyNumObject(BASE_SKINS.test.morph),
                fromColors: copyColorObject(BASE_SKINS.test.colors),
                toColors: copyColorObject(BASE_SKINS.test.colors),
                renderedColors: copyColorObject(BASE_SKINS.test.colors),
                motion: 0,
                blinkTimer: 0,
                blinkNext: 1.8 + Math.random() * 2.2,
                blinkDur: 0.13,
                blink: 0
            };

            function currentSkinDef() {
                return skinLibrary[skinState.activeId] || BASE_SKINS.test;
            }

            function loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load ${src}`));
                    img.src = src;
                });
            }

            function getAssetSkinState(def) {
                if (!assetSkinCache.has(def.id)) {
                    assetSkinCache.set(def.id, { requested: false, loaded: false, failed: [], images: {} });
                }
                return assetSkinCache.get(def.id);
            }

            function toCanonicalPartKey(key) {
                for (const [canon, aliases] of Object.entries(PART_KEY_ALIASES)) {
                    if (aliases.includes(key)) return canon;
                }
                return key;
            }

            function canonicalizePartMap(parts) {
                const out = {};
                for (const [k, v] of Object.entries(parts || {})) {
                    out[toCanonicalPartKey(k)] = v;
                }
                return out;
            }

            function canonicalizePartList(list) {
                return Array.from(new Set((list || []).map(toCanonicalPartKey)));
            }

            function normalizeLayerOrder(keys, order) {
                const keySet = new Set(keys);
                const seen = new Set();
                const out = [];
                (order || []).map(toCanonicalPartKey).forEach((k) => {
                    if (!keySet.has(k) || seen.has(k)) return;
                    seen.add(k);
                    out.push(k);
                });
                keys.forEach((k) => {
                    if (seen.has(k)) return;
                    seen.add(k);
                    out.push(k);
                });
                return out;
            }

            function fileNameFromPath(p) {
                const s = String(p || "");
                const i = Math.max(s.lastIndexOf("/"), s.lastIndexOf("\\"));
                return i >= 0 ? s.slice(i + 1) : s;
            }

            function semanticPartLabel(key) {
                const map = {
                    charLeftEye: "charLeftEye (model-left / viewer-right)",
                    charRightEye: "charRightEye (model-right / viewer-left)",
                    charLeftBrow: "charLeftBrow (model-left / viewer-right)",
                    charRightBrow: "charRightBrow (model-right / viewer-left)",
                    charLeftEarFill: "charLeftEarFill (model-left / viewer-right)",
                    charLeftEarLine: "charLeftEarLine (model-left / viewer-right)",
                    charLeftEarInner: "charLeftEarInner (model-left / viewer-right)",
                    charRightEarFill: "charRightEarFill (model-right / viewer-left)",
                    charRightEarLine: "charRightEarLine (model-right / viewer-left)",
                    charLeftArmDownFill: "charLeftArmDownFill (model-left / viewer-right)",
                    charLeftArmDownLine: "charLeftArmDownLine (model-left / viewer-right)",
                    charLeftArmUpFill: "charLeftArmUpFill (model-left / viewer-right)",
                    charLeftArmUpLine: "charLeftArmUpLine (model-left / viewer-right)",
                    charRightArmDownFill: "charRightArmDownFill (model-right / viewer-left)",
                    charRightArmDownLine: "charRightArmDownLine (model-right / viewer-left)",
                    charRightArmUpFill: "charRightArmUpFill (model-right / viewer-left)",
                    charRightArmUpLine: "charRightArmUpLine (model-right / viewer-left)"
                };
                if (map[key]) return map[key];
                if (key.startsWith("charLeft")) return `${key} (model-left / viewer-right)`;
                if (key.startsWith("charRight")) return `${key} (model-right / viewer-left)`;
                return key;
            }

            function clonePartTweaks(src) {
                const out = {};
                for (const [k, v] of Object.entries(src || {})) {
                    out[toCanonicalPartKey(k)] = {
                        x: +(v?.x || 0),
                        y: +(v?.y || 0),
                        w: +(v?.w || 0),
                        h: +(v?.h || 0)
                    };
                }
                return out;
            }

            function getInspectorState(def) {
                const st = getAssetSkinState(def);
                const parts = { ...DEFAULT_ASSET_PARTS, ...canonicalizePartMap(def.parts || {}) };
                const keys = Object.keys(parts);
                if (!st.inspectorReady) {
                    st.partsMap = { ...parts };
                    st.partTweaks = clonePartTweaks(def.partTweaks || {});
                    st.visibleSet = new Set(def.visibleParts || DEFAULT_VISIBLE_PARTS);
                    st.drawOrder = normalizeLayerOrder(keys, def.drawOrder || keys);
                    st.inspectorReady = true;
                } else {
                    st.partsMap = { ...parts, ...(st.partsMap || {}) };
                    st.drawOrder = normalizeLayerOrder(keys, st.drawOrder || keys);
                }
                return st;
            }

            function getActiveAssetSkinDef() {
                const target = skinLibrary[skinState.targetId];
                if (target?.mode === "asset") return target;
                const active = currentSkinDef();
                return (active.mode === "asset") ? active : null;
            }

            function ensurePartLoaded(def, key) {
                const st = getInspectorState(def);
                if (st.images[key]) return;
                const parts = st.partsMap || { ...DEFAULT_ASSET_PARTS, ...canonicalizePartMap(def.parts || {}) };
                const rel = parts[key];
                if (!rel) return;
                const src = def.root ? `${def.root}/${rel}` : rel;
                loadImage(src).then((img) => {
                    st.images[key] = img;
                    st.loaded = Object.keys(st.images).length > 0;
                }).catch(() => {
                    if (!st.failed.includes(src)) st.failed.push(src);
                });
            }

            function readPartBoxInputs() {
                return {
                    x: +(partDxEl.value || 0),
                    y: +(partDyEl.value || 0),
                    w: +(partDwEl.value || 0),
                    h: +(partDhEl.value || 0)
                };
            }

            function writePartBoxInputs(v) {
                const x = +(v?.x || 0);
                const y = +(v?.y || 0);
                const w = +(v?.w || 0);
                const h = +(v?.h || 0);
                partDxEl.value = String(x);
                partDyEl.value = String(y);
                partDwEl.value = String(w);
                partDhEl.value = String(h);
                partDxValEl.textContent = String(x);
                partDyValEl.textContent = String(y);
                partDwValEl.textContent = String(w);
                partDhValEl.textContent = String(h);
            }

            function refreshPartsInspector() {
                const def = getActiveAssetSkinDef();
                const disabled = !def;
                [partDxEl, partDyEl, partDwEl, partDhEl, partResetEl, partsResetAllEl, partCopyJsonEl, inspectorTabInputs, inspectorTabJson]
                    .forEach((el) => { el.disabled = disabled; });
                if (!def) {
                    partInspector.style.opacity = "0.55";
                    selectedPartLabelEl.textContent = "";
                    partJsonEl.value = "Select an asset skin to inspect parts.";
                    layerTableBody.innerHTML = "";
                    return;
                }
                partInspector.style.opacity = "1";

                const st = getInspectorState(def);
                const parts = st.partsMap || { ...DEFAULT_ASSET_PARTS, ...canonicalizePartMap(def.parts || {}) };
                const keys = Object.keys(parts);
                st.drawOrder = normalizeLayerOrder(keys, st.drawOrder || keys);
                if (!keys.includes(selectedPartKey)) selectedPartKey = st.drawOrder[0] || "";
                selectedPartLabelEl.textContent = selectedPartKey ? `[${selectedPartKey}]` : "";

                layerTableBody.innerHTML = "";
                st.drawOrder.forEach((k, idx) => {
                    const tr = document.createElement("tr");
                    tr.classList.add("draggable");
                    tr.draggable = false;
                    tr.dataset.key = k;
                    if (selectedPartKey === k) tr.classList.add("selected");
                    tr.addEventListener("click", (ev) => {
                        if (ev.target && ev.target.closest && ev.target.closest("input, select, button, label, .toggle, .file-input")) {
                            return;
                        }
                        selectedPartKey = k;
                        refreshPartsInspector();
                    });

                    const label = semanticOn ? semanticPartLabel(k) : k;
                    const file = parts[k] || "";
                    const vis = st.visibleSet.has(k);
                    const mappingOptions = keys.map((opt) =>
                        `<option value="${opt}" ${opt === k ? "selected" : ""}>${semanticOn ? semanticPartLabel(opt) : opt}</option>`
                    ).join("");

                    tr.innerHTML =
                        `<td class="col-layer"><span class="layer-idx">${idx + 1}</span><span class="layer-drag" title="Drag to reorder">‚ò∞‚ò∞</span></td>` +
                        `<td><select class="map-select">${mappingOptions}</select></td>` +
                        `<td><input class="file-input" type="text" value="${file.replace(/"/g, "&quot;")}" /></td>` +
                        `<td class="col-vis"><label class="toggle vis-toggle"><input type="checkbox" ${vis ? "checked" : ""} /><span class="toggle-ui"></span></label></td>`;

                    const mapEl = tr.querySelector(".map-select");
                    const fileEl = tr.querySelector(".file-input");
                    const layerDragEl = tr.querySelector(".layer-drag");
                    const visWrapEl = tr.querySelector(".vis-toggle");
                    const visEl = tr.querySelector(".vis-toggle input");
                    layerDragEl.draggable = true;
                    layerDragEl.addEventListener("dragstart", (ev) => {
                        tr.classList.add("dragging");
                        ev.dataTransfer.effectAllowed = "move";
                        ev.dataTransfer.setData("text/plain", k);
                    });
                    layerDragEl.addEventListener("dragend", () => {
                        tr.classList.remove("dragging");
                        Array.from(layerTableBody.querySelectorAll("tr.drop-target"))
                            .forEach((row) => row.classList.remove("drop-target"));
                    });
                    mapEl.addEventListener("click", (ev) => ev.stopPropagation());
                    mapEl.addEventListener("change", () => {
                        const target = mapEl.value;
                        if (!target || target === k) return;
                        const currentFile = parts[k];
                        const targetFile = parts[target];
                        parts[target] = currentFile;
                        parts[k] = targetFile;
                        const iA = st.drawOrder.indexOf(k);
                        const iB = st.drawOrder.indexOf(target);
                        if (iA >= 0 && iB >= 0) {
                            st.drawOrder[iA] = target;
                            st.drawOrder[iB] = k;
                        }
                        if (selectedPartKey === k) selectedPartKey = target;
                        else if (selectedPartKey === target) selectedPartKey = k;
                        st.requested = false;
                        st.loaded = false;
                        st.images = {};
                        loadAssetSkin(def);
                        refreshPartsInspector();
                    });
                    fileEl.addEventListener("click", (ev) => ev.stopPropagation());
                    fileEl.addEventListener("change", () => {
                        parts[k] = (fileEl.value || "").trim();
                        delete st.images[k];
                        if (st.visibleSet.has(k)) ensurePartLoaded(def, k);
                        refreshPartsInspector();
                    });
                    visWrapEl.addEventListener("pointerdown", (ev) => ev.stopPropagation());
                    visWrapEl.addEventListener("click", (ev) => ev.stopPropagation());
                    visEl.addEventListener("click", (ev) => ev.stopPropagation());
                    visEl.addEventListener("change", () => {
                        if (visEl.checked) {
                            st.visibleSet.add(k);
                            ensurePartLoaded(def, k);
                        } else {
                            st.visibleSet.delete(k);
                        }
                        refreshPartsInspector();
                    });

                    tr.addEventListener("dragover", (ev) => {
                        ev.preventDefault();
                        ev.dataTransfer.dropEffect = "move";
                        if (!tr.classList.contains("dragging")) tr.classList.add("drop-target");
                    });
                    tr.addEventListener("dragleave", () => {
                        tr.classList.remove("drop-target");
                    });
                    tr.addEventListener("drop", (ev) => {
                        ev.preventDefault();
                        tr.classList.remove("drop-target");
                        const fromKey = ev.dataTransfer.getData("text/plain");
                        const toKey = k;
                        if (!fromKey || fromKey === toKey) return;
                        const fromIdx = st.drawOrder.indexOf(fromKey);
                        const toIdx = st.drawOrder.indexOf(toKey);
                        if (fromIdx < 0 || toIdx < 0) return;
                        st.drawOrder.splice(fromIdx, 1);
                        st.drawOrder.splice(toIdx, 0, fromKey);
                        refreshPartsInspector();
                    });

                    layerTableBody.appendChild(tr);
                });

                writePartBoxInputs(st.partTweaks[selectedPartKey] || { x: 0, y: 0, w: 0, h: 0 });
                partJsonEl.value = JSON.stringify({
                    visibleParts: Array.from(st.visibleSet),
                    drawOrder: st.drawOrder,
                    parts: parts,
                    partTweaks: st.partTweaks
                }, null, 2);
            }

            function loadAssetSkin(def) {
                const state = getInspectorState(def);
                if (state.requested) return;
                state.requested = true;
                const parts = state.partsMap || { ...DEFAULT_ASSET_PARTS, ...canonicalizePartMap(def.parts || {}) };
                const root = def.root || "";
                const loadKeys = Array.from(state.visibleSet).filter((k) => !!parts[k]);

                const jobs = loadKeys.map(async (key) => {
                    const rel = parts[key];
                    const src = root ? `${root}/${rel}` : rel;
                    try {
                        const img = await loadImage(src);
                        state.images[key] = img;
                    } catch (_) {
                        state.failed.push(src);
                    }
                });

                Promise.all(jobs).then(() => {
                    state.loaded = Object.keys(state.images).length > 0;
                    if (!state.loaded) {
                        console.warn(`Asset skin '${def.id}' did not load any images. Check ${root}/manifest.json paths.`);
                    } else if (state.failed.length) {
                        console.warn(`Some asset files failed for skin '${def.id}':`, state.failed);
                    }
                });
            }

            function normalizeAssetSkin(id, manifest) {
                const m = manifest || {};
                const parts = canonicalizePartMap(m.parts || {});
                const keys = Object.keys({ ...DEFAULT_ASSET_PARTS, ...parts });
                return {
                    id,
                    label: m.label || id,
                    mode: "asset",
                    root: `skins/${id}`,
                    parts,
                    visibleParts: Array.isArray(m.visibleParts) ? canonicalizePartList(m.visibleParts) : DEFAULT_VISIBLE_PARTS.slice(),
                    drawOrder: normalizeLayerOrder(keys, Array.isArray(m.drawOrder) ? m.drawOrder : keys),
                    partTweaks: clonePartTweaks(m.partTweaks || {}),
                    hideDefaultArms: !!m.hideDefaultArms,
                    morph: { ...BASE_SKINS.test.morph, ...(m.morph || {}) },
                    colors: { ...BASE_SKINS.test.colors, ...(m.colors || {}) }
                };
            }

            async function loadManifestSkins() {
                try {
                    const res = await fetch("skins/index.json", { cache: "no-store" });
                    if (!res.ok) return;
                    const data = await res.json();
                    const ids = Array.isArray(data) ? data : Array.isArray(data?.skins) ? data.skins : [];
                    for (const idRaw of ids) {
                        const id = String(idRaw || "").trim();
                        if (!id) continue;
                        try {
                            const manifestRes = await fetch(`skins/${id}/manifest.json`, { cache: "no-store" });
                            if (!manifestRes.ok) continue;
                            const manifest = await manifestRes.json();
                            const skin = normalizeAssetSkin(id, manifest);
                            skinLibrary[skin.id] = skin;
                        } catch (_) {
                            console.warn(`Could not load skin manifest for '${id}'.`);
                        }
                    }
                } catch (_) {
                    // When running as file://, fetch may fail. Keep built-in skins.
                }
            }

            function switchSkin(id) {
                const next = skinLibrary[id];
                if (!next || id === skinState.targetId) return;
                if (next.mode === "asset") loadAssetSkin(next);
                skinState.targetId = id;
                skinState.t = 0;
                skinState.fromMorph = copyNumObject(skinState.renderedMorph);
                skinState.toMorph = copyNumObject(next.morph);
                skinState.fromColors = copyColorObject(skinState.renderedColors);
                skinState.toColors = copyColorObject(next.colors);
                refreshPartsInspector();
            }

            function updateSkin(dt, activity) {
                if (skinState.t < 1) {
                    skinState.t = Math.min(1, skinState.t + dt / skinState.dur);
                    const s = easeOutCubic(skinState.t);
                    skinState.renderedMorph = lerpNumObject(skinState.fromMorph, skinState.toMorph, s);
                    skinState.renderedColors = lerpColorObject(skinState.fromColors, skinState.toColors, s);
                    if (skinState.t >= 1) skinState.activeId = skinState.targetId;
                }

                skinState.motion = lerp(skinState.motion, activity, 1 - Math.pow(0.001, dt * 6));

                skinState.blinkTimer += dt;
                if (skinState.blinkTimer >= skinState.blinkNext) {
                    const t = skinState.blinkTimer - skinState.blinkNext;
                    const p = clamp(t / skinState.blinkDur, 0, 1);
                    skinState.blink = (p < 0.5) ? p * 2 : (1 - p) * 2;
                    if (p >= 1) {
                        skinState.blinkTimer = 0;
                        skinState.blink = 0;
                        skinState.blinkNext = 1.6 + Math.random() * 2.6;
                    }
                } else {
                    skinState.blink = 0;
                }
            }

            function activeMouseHeld() {
                return !!(mTargets?.left?.held || mTargets?.right?.held || mTargets?.middle?.held);
            }

            function ensureMouseMoveTarget() {
                const t = pressed.get("mouse_move");
                if (mouseMoveTimer > 0) {
                    if (!t) pressed.set("mouse_move", { id: "mouse_move", x: mouseCenter.x, y: mouseCenter.y, type: "mouse", held: true });
                    else { t.held = true; t.x = mouseCenter.x; t.y = mouseCenter.y; }
                } else {
                    if (t) t.held = false;
                }
            }

            function startSmash(arm, target) {
                arm.target.x = target.x;
                arm.target.y = target.y;
                arm.t = 0;
                arm.phase = "go";
                arm.impact = 0;
                arm.holdImpact = 0;
                if (audio) audio.clack();
            }

            function chooseMouseArm() {
                const dL = Math.hypot(mouseCenter.x - armL.shoulder.x, mouseCenter.y - armL.shoulder.y);
                const dR = Math.hypot(mouseCenter.x - armR.shoulder.x, mouseCenter.y - armR.shoulder.y);
                return (dL <= dR) ? armL : armR;
            }

            function assignTargets() {
                ensureMouseMoveTarget();

                const heldTargets = Array.from(pressed.values()).filter(t => t.held);
                const mouseActive = (mouseMoveTimer > 0) || activeMouseHeld();

                [armL, armR].forEach(a => {
                    if (a.assignedId) {
                        const t = pressed.get(a.assignedId);
                        if (!t || !t.held) a.assignedId = null;
                    }
                });

                if (mouseActive) {
                    const mouseArm = chooseMouseArm();
                    const keyArm = (mouseArm === armL) ? armR : armL;

                    let mouseTarget = null;
                    if (mTargets?.left?.held) mouseTarget = pressed.get("mouse_left");
                    if (mTargets?.right?.held) mouseTarget = pressed.get("mouse_right");
                    if (mTargets?.middle?.held) mouseTarget = pressed.get("mouse_mid");
                    if (!mouseTarget) mouseTarget = pressed.get("mouse_move");

                    if (mouseTarget?.held) {
                        if (mouseArm.assignedId !== mouseTarget.id) {
                            mouseArm.assignedId = mouseTarget.id;
                            startSmash(mouseArm, mouseTarget);
                        }
                    } else {
                        mouseArm.assignedId = null;
                    }

                    const keyTargets = heldTargets.filter(t => t.type === "key");
                    if (keyTargets.length) {
                        let best = keyTargets[0], bestD = Infinity;
                        for (const t of keyTargets) {
                            const d = Math.hypot(t.x - keyArm.shoulder.x, t.y - keyArm.shoulder.y);
                            if (d < bestD) { bestD = d; best = t; }
                        }
                        if (keyArm.assignedId !== best.id) {
                            keyArm.assignedId = best.id;
                            startSmash(keyArm, best);
                        }
                    } else {
                        if (keyArm.assignedId && pressed.get(keyArm.assignedId)?.type === "key") keyArm.assignedId = null;
                    }
                    return;
                }

                const keyTargets = heldTargets.filter(t => t.type === "key");
                const taken = new Set([armL.assignedId, armR.assignedId].filter(Boolean));
                const freeTargets = keyTargets.filter(t => !taken.has(t.id));
                const freeArms = [armL, armR].filter(a => !a.assignedId);

                freeArms.forEach(arm => {
                    if (!freeTargets.length) return;
                    let bestIdx = 0, bestD = Infinity;
                    for (let i = 0; i < freeTargets.length; i++) {
                        const t = freeTargets[i];
                        const d = Math.hypot(t.x - arm.shoulder.x, t.y - arm.shoulder.y);
                        if (d < bestD) { bestD = d; bestIdx = i; }
                    }
                    const chosen = freeTargets.splice(bestIdx, 1)[0];
                    arm.assignedId = chosen.id;
                    startSmash(arm, chosen);
                });
            }

            // ===== INPUT
            window.addEventListener("keydown", (e) => {
                if (e.repeat) return;
                if (!isTyping()) {
                    if (["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.code)) e.preventDefault();
                }
                const label = labelFromCode(e);
                if (!label) return;

                const k = keys.find(x => x.label === label);
                if (!k) return;

                k.held = true;

                const LAYOUT = layout();
                const kb = LAYOUT.keyboard;

                // both-axis flip for the target position
                const xVis = kb.x + kb.w - (k.x - kb.x) - k.w;
                const yVis = kb.y + kb.h - (k.y - kb.y) - k.h;

                pressed.set(k.id, {
                    id: k.id,
                    x: xVis + k.w * 0.5,
                    y: yVis + k.h * 0.60,
                    type: "key",
                    held: true
                });


                assignTargets();
            }, { passive: false });

            window.addEventListener("keyup", (e) => {
                const label = labelFromCode(e);
                if (!label) return;

                keys.forEach(k => {
                    if (k.label === label) {
                        k.held = false;
                        const t = pressed.get(k.id);
                        if (t) t.held = false;
                    }
                });
                assignTargets();
            });

            window.addEventListener("mousedown", (e) => {
                if (!mTargets) return;
                let btn = null;
                if (e.button === 0) btn = mTargets.left;
                if (e.button === 1) btn = mTargets.middle;
                if (e.button === 2) btn = mTargets.right;
                if (!btn) return;

                btn.held = true;
                pressed.set(btn.id, { id: btn.id, x: btn.x, y: btn.y, type: "mouse", held: true });
                assignTargets();
            });

            window.addEventListener("mouseup", (e) => {
                if (!mTargets) return;
                let id = null;
                if (e.button === 0) id = "mouse_left";
                if (e.button === 1) id = "mouse_mid";
                if (e.button === 2) id = "mouse_right";
                if (!id) return;

                const t = pressed.get(id);
                if (t) t.held = false;

                if (id === "mouse_left") mTargets.left.held = false;
                if (id === "mouse_mid") mTargets.middle.held = false;
                if (id === "mouse_right") mTargets.right.held = false;

                assignTargets();
            });

            window.addEventListener("contextmenu", (e) => e.preventDefault());

            // Mouse movement -> slide mouse on pad
            let lastClientX = null, lastClientY = null;
            window.addEventListener("mousemove", (e) => {
                if (!mousePad || !mouseSize) return;

                if (lastClientX == null) { lastClientX = e.clientX; lastClientY = e.clientY; return; }
                const dx = e.clientX - lastClientX;
                const dy = e.clientY - lastClientY;
                lastClientX = e.clientX; lastClientY = e.clientY;

                const s = 0.85;
                const next = clampMouseToPad(mouseCenter.x - dx * s, mouseCenter.y - dy * s, mousePad, mouseSize);
                const moved = (Math.abs(next.x - mouseCenter.x) + Math.abs(next.y - mouseCenter.y)) > 0.01;

                mouseCenter = next;

                mTargets = mouseTargetsFromCenter(mouseCenter.x, mouseCenter.y, mouseSize);
                mTargets.left.held = !!pressed.get("mouse_left")?.held;
                mTargets.right.held = !!pressed.get("mouse_right")?.held;
                mTargets.middle.held = !!pressed.get("mouse_mid")?.held;

                if (moved) {
                    mouseMoveTimer = 0.22;
                    if (pressed.get("mouse_left")?.held) (pressed.get("mouse_left").x = mTargets.left.x, pressed.get("mouse_left").y = mTargets.left.y);
                    if (pressed.get("mouse_right")?.held) (pressed.get("mouse_right").x = mTargets.right.x, pressed.get("mouse_right").y = mTargets.right.y);
                    if (pressed.get("mouse_mid")?.held) (pressed.get("mouse_mid").x = mTargets.middle.x, pressed.get("mouse_mid").y = mTargets.middle.y);

                    assignTargets();
                }
            }, { passive: true });

            // ===== DRAW HELPERS
            function flipRect180InBox(rect, box) {
                // 180√Ç¬∞ flip around the box center:
                // x' = box.x + box.w - (x - box.x) - w
                // y' = box.y + box.h - (y - box.y) - h
                return {
                    x: box.x + box.w - (rect.x - box.x) - rect.w,
                    y: box.y + box.h - (rect.y - box.y) - rect.h,
                };
            }

            function drawDesk(LAYOUT) {
                const { w, h, deskTopY } = LAYOUT;
                ctx.fillStyle = "rgb(18, 20, 26)";
                ctx.fillRect(0, deskTopY, w, h - deskTopY);
                ctx.fillStyle = "rgba(255,255,255,0.07)";
                ctx.fillRect(0, deskTopY - 3, w, 3);
                const g = ctx.createLinearGradient(0, deskTopY, 0, h);
                g.addColorStop(0, "rgba(255,255,255,0.03)");
                g.addColorStop(1, "rgba(0,0,0,0.18)");
                ctx.fillStyle = g;
                ctx.fillRect(0, deskTopY, w, h - deskTopY);
            }

            function drawImageFit(img, x, y, w, h, alpha = 1) {
                if (!img) return;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.drawImage(img, x, y, w, h);
                ctx.restore();
            }

            function drawCustomAssetCharacter(LAYOUT, skinDef) {
                const state = getInspectorState(skinDef);
                const img = state.images;
                const visible = state.visibleSet;
                const tweaks = state.partTweaks || {};
                const parts = state.partsMap || { ...DEFAULT_ASSET_PARTS, ...canonicalizePartMap(skinDef.parts || {}) };
                const keys = Object.keys(parts);
                state.drawOrder = normalizeLayerOrder(keys, state.drawOrder || keys);
                const orderMap = new Map(state.drawOrder.map((k, i) => [k, i]));
                const boxes = [];
                let drawSeq = 0;
                const head = LAYOUT.head;
                const pulse = Math.sin(sceneTime * 4.8) * 0.5 + 0.5;
                const mouthDrive = clamp(skinState.motion * 0.9 + pulse * 0.25, 0, 1.4);
                const eyeOpen = clamp(1 - skinState.blink - skinState.motion * 0.24, 0.10, 1);
                const drawImmediateSorted = (queue) => {
                    queue.sort((a, b) => (a.z - b.z) || (a.s - b.s));
                    queue.forEach((q) => {
                        boxes.push({ key: q.key, x: q.x, y: q.y, w: q.w, h: q.h });
                        drawImageFit(q.img, q.x, q.y, q.w, q.h);
                    });
                    queue.length = 0;
                };
                const queueRoot = [];
                const queueHead = [];
                let queue = queueRoot;
                const drawPart = (key, x, y, w, h) => {
                    if (!visible.has(key)) return;
                    const t = tweaks[key] || { x: 0, y: 0, w: 0, h: 0 };
                    const partImg = img[key];
                    const nW = Math.max(1, partImg?.naturalWidth || partImg?.width || w || 1);
                    const nH = Math.max(1, partImg?.naturalHeight || partImg?.height || h || 1);

                    // Keep native part proportions: fit image into its default slot without distortion.
                    const contain = Math.min(w / nW, h / nH);
                    const fitW = Math.max(2, nW * contain);
                    const fitH = Math.max(2, nH * contain);
                    const fitX = x + (w - fitW) * 0.5;
                    const fitY = y + (h - fitH) * 0.5;

                    // Tweaks are relative scale percentages from the natural fit size.
                    const sx = Math.max(0.05, 1 + (t.w / 100));
                    const sy = Math.max(0.05, 1 + (t.h / 100));
                    const bw = Math.max(2, fitW * sx);
                    const bh = Math.max(2, fitH * sy);
                    const bx = fitX + (fitW - bw) * 0.5 + t.x;
                    const by = fitY + (fitH - bh) * 0.5 + t.y;
                    queue.push({
                        key,
                        img: partImg,
                        x: bx,
                        y: by,
                        w: bw,
                        h: bh,
                        z: orderMap.has(key) ? orderMap.get(key) : 9999,
                        s: drawSeq++
                    });
                };

                const bodyW = head.w * 1.95;
                const bodyH = bodyW * 1.08;
                const bodyX = head.x + head.w * 0.5 - bodyW * 0.5;
                const bodyY = LAYOUT.deskTopY - bodyH * 0.52;

                const tailW = head.w * 0.85;
                const tailH = tailW * 0.9;
                const tailX = head.x + head.w * 0.78;
                const tailY = LAYOUT.deskTopY - tailH * 0.08;

                drawPart("tailFill", tailX, tailY, tailW, tailH);
                drawPart("tailLine", tailX, tailY, tailW, tailH);
                drawPart("bodyFill", bodyX, bodyY, bodyW, bodyH);
                drawPart("bodyLine", bodyX, bodyY, bodyW, bodyH);

                const leftImpact = clamp(armR ? armR.impact : 0, 0, 1);
                const rightImpact = clamp(armL ? armL.impact : 0, 0, 1);
                const armDownLeft = leftImpact < 0.45;
                const armDownRight = rightImpact < 0.45;
                const leftArmBaseX = head.x + head.w * 0.64;
                const leftArmBaseY = LAYOUT.deskTopY - head.h * 0.02;
                const rightArmBaseX = head.x - head.w * 0.44;
                const rightArmBaseY = LAYOUT.deskTopY - head.h * 0.02;
                const armW = head.w * 0.95;
                const armH = head.h * 1.02;
                if (armDownLeft) {
                    const downStretch = 1 + leftImpact * 0.12;
                    drawPart("charLeftArmDownFill", leftArmBaseX, leftArmBaseY - head.h * 0.03 * leftImpact, armW, armH * downStretch);
                    drawPart("charLeftArmDownLine", leftArmBaseX, leftArmBaseY - head.h * 0.03 * leftImpact, armW, armH * downStretch);
                } else {
                    const lift = head.h * (0.16 + leftImpact * 0.12);
                    const squeeze = 1 - leftImpact * 0.12;
                    drawPart("charLeftArmUpFill", leftArmBaseX + head.w * 0.01 * leftImpact, leftArmBaseY - lift, armW * squeeze, armH * (1 + leftImpact * 0.10));
                    drawPart("charLeftArmUpLine", leftArmBaseX + head.w * 0.01 * leftImpact, leftArmBaseY - lift, armW * squeeze, armH * (1 + leftImpact * 0.10));
                }
                if (armDownRight) {
                    const downStretch = 1 + rightImpact * 0.12;
                    drawPart("charRightArmDownFill", rightArmBaseX, rightArmBaseY - head.h * 0.03 * rightImpact, armW, armH * downStretch);
                    drawPart("charRightArmDownLine", rightArmBaseX, rightArmBaseY - head.h * 0.03 * rightImpact, armW, armH * downStretch);
                } else {
                    const lift = head.h * (0.16 + rightImpact * 0.12);
                    const squeeze = 1 - rightImpact * 0.12;
                    drawPart("charRightArmUpFill", rightArmBaseX - head.w * 0.01 * rightImpact, rightArmBaseY - lift, armW * squeeze, armH * (1 + rightImpact * 0.10));
                    drawPart("charRightArmUpLine", rightArmBaseX - head.w * 0.01 * rightImpact, rightArmBaseY - lift, armW * squeeze, armH * (1 + rightImpact * 0.10));
                }
                drawImmediateSorted(queueRoot);

                ctx.save();
                ctx.translate(head.x + head.w * 0.5, head.y + head.h * 0.5 + headBob.y);
                ctx.scale(1 + headBob.y * 0.001, 1 - headBob.y * 0.002);
                ctx.translate(-head.w * 0.5, -head.h * 0.5);
                queue = queueHead;

                const earBounce = Math.sin(sceneTime * 7.2) * 0.5 + 0.5;
                const earWobble = clamp(Math.abs(headBob.y) / 18 + skinState.motion * 0.35, 0, 1);
                const earW = head.w * (0.46 + earWobble * 0.04);
                const earH = head.h * (0.58 - earWobble * 0.10);
                const lEarX = head.w * -0.18;
                const rEarX = head.w * 0.70;
                const earY = head.h * (-0.20 + (earBounce - 0.5) * 0.03 + headBob.y * 0.0009);

                // model-left appears viewer-right when character faces viewer.
                drawPart("charLeftEarFill", rEarX, earY, earW, earH);
                drawPart("charLeftEarLine", rEarX, earY, earW, earH);
                drawPart("charLeftEarInner", rEarX, earY, earW, earH);
                drawPart("charRightEarFill", lEarX, earY, earW, earH);
                drawPart("charRightEarLine", lEarX, earY, earW, earH);

                drawPart("headFill", 0, 0, head.w, head.h);
                drawPart("headLine", 0, 0, head.w, head.h);

                const eyeW = head.w * 0.20;
                const eyeH = head.h * 0.28 * eyeOpen;
                const lEyeX = head.w * 0.20;
                const rEyeX = head.w * 0.60;
                const eyeY = head.h * 0.36 + (1 - eyeOpen) * head.h * 0.10;
                drawPart("charLeftEye", rEyeX, eyeY, eyeW, eyeH);
                drawPart("charRightEye", lEyeX, eyeY, eyeW, eyeH);

                const browW = head.w * 0.26;
                const browH = head.h * 0.18;
                const browY = eyeY - browH * (0.78 + skinState.motion * 0.25);
                drawPart("charLeftBrow", head.w * 0.59, browY, browW, browH);
                drawPart("charRightBrow", head.w * 0.15, browY, browW, browH);

                const mouthW = head.w * (0.26 + skinState.motion * 0.03);
                const mouthH = head.h * (0.12 + mouthDrive * 0.03);
                drawPart("mouth", head.w * 0.50 - mouthW * 0.5, head.h * 0.70, mouthW, mouthH);
                drawImmediateSorted(queueHead);
                ctx.restore();
                lastAssetBoxes = boxes;
            }

            function drawHead(LAYOUT) {
                const active = currentSkinDef();
                if (active.mode === "asset") {
                    const state = getAssetSkinState(active);
                    if (!state.requested) loadAssetSkin(active);
                    if (state.loaded) {
                        drawCustomAssetCharacter(LAYOUT, active);
                        return;
                    }
                }

                if (active.mode === "asset") {
                    // asset skin still loading/failing -> fallback to procedural look this frame
                }
                lastAssetBoxes = [];

                const head = LAYOUT.head;
                const squash = 1 - headBob.y * 0.002;
                const stretch = 1 + headBob.y * 0.001;
                const morph = skinState.renderedMorph;
                const col = skinState.renderedColors;
                const pulse = Math.sin(sceneTime * 4.8) * 0.5 + 0.5;
                const mouthDrive = clamp(skinState.motion * 0.9 + pulse * 0.25, 0, 1.4);
                const eyeOpen = clamp(1 - skinState.blink - skinState.motion * morph.squint, 0.12, 1);

                ctx.save();
                ctx.translate(head.x + head.w / 2, head.y + head.h / 2 + headBob.y);
                ctx.scale(stretch, squash);
                ctx.translate(-head.w / 2, -head.h / 2);

                const earW = head.w * morph.earWidth;
                const earH = head.h * morph.earHeight;
                const leftEarX = head.w * 0.16 - earW * 0.5;
                const rightEarX = head.w * 0.84 - earW * 0.5;
                const earY = -earH * 0.52;

                ctx.fillStyle = rgba(col.skin);
                roundRect(leftEarX, earY, earW, earH, earW * 0.36);
                ctx.fill();
                roundRect(rightEarX, earY, earW, earH, earW * 0.36);
                ctx.fill();

                ctx.fillStyle = rgba(col.skin);
                roundRect(0, 0, head.w, head.h, head.w * morph.round);
                ctx.fill();

                if (morph.hornSize > 0.001) {
                    const hornR = head.w * morph.hornSize;
                    ctx.fillStyle = rgba(col.horn);
                    ctx.beginPath();
                    ctx.ellipse(head.w * 0.40, -hornR * 0.35, hornR * 0.75, hornR, -0.25, 0, Math.PI * 2);
                    ctx.ellipse(head.w * 0.60, -hornR * 0.35, hornR * 0.75, hornR, 0.25, 0, Math.PI * 2);
                    ctx.fill();
                }

                const eyeY = head.h * 0.52;
                const eyeRX = head.w * morph.eyeWidth;
                const eyeRY = head.h * morph.eyeHeight * eyeOpen;
                const eyeLX = head.w * (0.50 - morph.eyeGap);
                const eyeRXPos = head.w * (0.50 + morph.eyeGap);

                ctx.fillStyle = rgba(col.eye);
                ctx.beginPath();
                ctx.ellipse(eyeLX, eyeY, eyeRX, eyeRY, 0, 0, Math.PI * 2);
                ctx.ellipse(eyeRXPos, eyeY, eyeRX, eyeRY, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = rgba(col.brow);
                ctx.lineWidth = Math.max(2, head.w * 0.02);
                ctx.lineCap = "round";
                ctx.beginPath();
                ctx.moveTo(eyeLX - eyeRX * 0.9, eyeY - eyeRY * 2.0);
                ctx.lineTo(eyeLX + eyeRX * 0.9, eyeY - eyeRY * (2.0 + morph.browTilt));
                ctx.moveTo(eyeRXPos - eyeRX * 0.9, eyeY - eyeRY * (2.0 + morph.browTilt));
                ctx.lineTo(eyeRXPos + eyeRX * 0.9, eyeY - eyeRY * 2.0);
                ctx.stroke();

                ctx.fillStyle = rgba(col.blush);
                ctx.beginPath();
                ctx.ellipse(head.w * 0.22, head.h * 0.66, head.w * morph.blushWidth, head.h * morph.blushHeight, 0, 0, Math.PI * 2);
                ctx.ellipse(head.w * 0.78, head.h * 0.66, head.w * morph.blushWidth, head.h * morph.blushHeight, 0, 0, Math.PI * 2);
                ctx.fill();

                const mouthW = head.w * morph.mouthWidth * (1 + skinState.motion * 0.18);
                const mouthH = head.h * morph.mouthHeight * (0.50 + mouthDrive);
                const mouthY = head.h * morph.mouthY;

                ctx.fillStyle = rgba(col.mouth);
                roundRect(head.w * 0.5 - mouthW * 0.5, mouthY - mouthH * 0.5, mouthW, mouthH, mouthH * 0.75);
                ctx.fill();

                ctx.restore();
            }

            function drawKeyboard(LAYOUT) {
                const kb = LAYOUT.keyboard;

                // base
                ctx.fillStyle = "rgba(255,255,255,0.06)";
                roundRect(kb.x, kb.y, kb.w, kb.h, kb.h * 0.16);
                ctx.fill();

                const fontPx = clamp(keys[0].h * 0.42, 10, 18);
                ctx.font = `${fontPx}px system-ui`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                keys.forEach(k => {
                    // √¢≈ì‚Ä¶ flip key position on BOTH axes
                    const flipped = flipRect180InBox({ x: k.x, y: k.y, w: k.w, h: k.h }, kb);

                    const press = clamp(k.press, 0, 1);
                    const dy = press * (k.h * 0.18);

                    // keycap
                    ctx.fillStyle = "rgba(255,255,255,0.07)";
                    roundRect(flipped.x, flipped.y + dy, k.w, k.h, k.h * 0.25);
                    ctx.fill();

                    // √¢≈ì‚Ä¶ label upside-down too (rotate text 180√Ç¬∞ around its center)
                    const cx = flipped.x + k.w / 2;
                    const cy = flipped.y + dy + k.h / 2;

                    ctx.fillStyle = "rgba(255,255,255,0.18)";
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(Math.PI);
                    ctx.fillText(k.label, 0, 0);
                    ctx.restore();
                });
            }


            function drawMouse(LAYOUT) {
                const pad = LAYOUT.mousepad;

                ctx.fillStyle = "rgba(255,255,255,0.03)";
                roundRect(pad.x, pad.y, pad.w, pad.h, 14);
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.06)";
                ctx.lineWidth = 1;
                roundRect(pad.x, pad.y, pad.w, pad.h, 14);
                ctx.stroke();

                const cx = mouseCenter.x, cy = mouseCenter.y;
                const w = mouseSize.w, h = mouseSize.h;

                ctx.fillStyle = "rgba(255,255,255,0.06)";
                roundRect(cx - w / 2, cy - h / 2, w, h, w * 0.45);
                ctx.fill();

                const t = mTargets;

                function drawBtn(btn) {
                    const dy = clamp(btn.press, 0, 1) * (btn.r * 0.55);
                    ctx.fillStyle = "rgba(255,255,255,0.10)";
                    ctx.beginPath();
                    ctx.ellipse(btn.x, btn.y + dy, btn.r * 1.25, btn.r, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                drawBtn(t.left);
                drawBtn(t.right);

                const dy = clamp(t.middle.press, 0, 1) * (t.middle.r * 0.55);
                ctx.fillStyle = "rgba(255,255,255,0.10)";
                ctx.beginPath();
                ctx.ellipse(t.middle.x, t.middle.y + dy, t.middle.r * 0.8, t.middle.r * 1.2, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            function drawSkeletonOverlay(LAYOUT) {
                if (!skeletonOn) return;

                const drawBox = (label, x, y, w, h, color) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.25;
                    ctx.strokeRect(x, y, w, h);
                    ctx.fillStyle = color;
                    ctx.font = "11px monospace";
                    ctx.textAlign = "left";
                    ctx.textBaseline = "top";
                    ctx.fillText(label, x + 2, y + 2);
                };

                drawBox("head", LAYOUT.head.x, LAYOUT.head.y, LAYOUT.head.w, LAYOUT.head.h, "rgba(110,231,255,0.75)");
                drawBox("keyboard", LAYOUT.keyboard.x, LAYOUT.keyboard.y, LAYOUT.keyboard.w, LAYOUT.keyboard.h, "rgba(255,220,120,0.75)");
                drawBox("mousepad", LAYOUT.mousepad.x, LAYOUT.mousepad.y, LAYOUT.mousepad.w, LAYOUT.mousepad.h, "rgba(170,255,180,0.75)");

                ctx.fillStyle = "rgba(255,150,120,0.85)";
                [LAYOUT.shoulderL, LAYOUT.shoulderR, LAYOUT.restL, LAYOUT.restR].forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillText(["shoulderL", "shoulderR", "restL", "restR"][i], p.x + 6, p.y + 2);
                });

                lastAssetBoxes.forEach((b) => drawBox(semanticOn ? semanticPartLabel(b.key) : b.key, b.x, b.y, b.w, b.h, "rgba(255,110,220,0.62)"));
            }

            function drawArm(arm) {
                const sx = arm.shoulder.x, sy = arm.shoulder.y;
                const px = arm.pos.x, py = arm.pos.y;

                const dx = px - sx, dy = py - sy;
                const dist = Math.hypot(dx, dy) || 1;
                const nx = dx / dist, ny = dy / dist;

                const th = 10 + arm.impact * 8;

                ctx.strokeStyle = "rgba(255,255,255,0.18)";
                ctx.lineWidth = th;
                ctx.lineCap = "round";
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(px - nx * 10, py - ny * 10);
                ctx.stroke();

                ctx.fillStyle = "rgba(255,255,255,0.22)";
                ctx.beginPath();
                ctx.ellipse(px, py, 18 + arm.impact * 6, 14 - arm.impact * 3, Math.atan2(dy, dx), 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== UPDATE / DRAW LOOP
            function update(dt) {
                sceneTime += dt;
                mouseMoveTimer = Math.max(0, mouseMoveTimer - dt);

                keys.forEach(k => {
                    const target = k.held ? 1 : 0;
                    const speed = k.held ? 18 : 9;
                    k.press = lerp(k.press, target, 1 - Math.pow(0.001, dt * speed));
                });

                [mTargets.left, mTargets.right, mTargets.middle].forEach(btn => {
                    const t = pressed.get(btn.id);
                    btn.held = !!t?.held;
                    const target = btn.held ? 1 : 0;
                    const speed = btn.held ? 18 : 9;
                    btn.press = lerp(btn.press, target, 1 - Math.pow(0.001, dt * speed));
                });

                assignTargets();

                [armL, armR].forEach(arm => {
                    const assigned = arm.assignedId ? pressed.get(arm.assignedId) : null;
                    const isHeld = !!(assigned && assigned.held);
                    if (assigned) { arm.target.x = assigned.x; arm.target.y = assigned.y; }

                    if (arm.phase === "idle") {
                        arm.pos.x = lerp(arm.pos.x, arm.rest.x, 1 - Math.pow(0.001, dt * 16));
                        arm.pos.y = lerp(arm.pos.y, arm.rest.y, 1 - Math.pow(0.001, dt * 16));
                        arm.impact = Math.max(0, arm.impact - dt * 8);
                        if (arm.assignedId && isHeld) startSmash(arm, assigned);
                        return;
                    }

                    if (arm.phase === "go") {
                        arm.t += dt;
                        const t = clamp(arm.t / arm.dur, 0, 1);
                        const s = smashEase(t);
                        arm.pos.x = lerp(arm.rest.x, arm.target.x, s);
                        arm.pos.y = lerp(arm.rest.y, arm.target.y, s);
                        arm.impact = Math.max(arm.impact, t);
                        if (t >= 1) {
                            arm.phase = "hold";
                            arm.t = 0;
                            arm.impact = 1;
                            arm.holdImpact = 1;
                            headBob.v += 180;
                            if (audio) audio.thunk();
                        }
                        return;
                    }

                    if (arm.phase === "hold") {
                        arm.holdImpact = Math.max(0, arm.holdImpact - dt * 6);
                        arm.impact = Math.max(0.18, arm.holdImpact);
                        arm.pos.x = lerp(arm.pos.x, arm.target.x, 1 - Math.pow(0.001, dt * 30));
                        arm.pos.y = lerp(arm.pos.y, arm.target.y, 1 - Math.pow(0.001, dt * 30));
                        if (!isHeld) { arm.phase = "return"; arm.t = 0; }
                        return;
                    }

                    if (arm.phase === "return") {
                        arm.t += dt;
                        const t = clamp(arm.t / 0.18, 0, 1);
                        const s = easeOutCubic(t);
                        arm.pos.x = lerp(arm.target.x, arm.rest.x, s);
                        arm.pos.y = lerp(arm.target.y, arm.rest.y, s);
                        arm.impact = Math.max(0, 1 - t * 1.2);
                        if (t >= 1) {
                            arm.phase = "idle";
                            arm.impact = 0;
                            arm.pos.x = arm.rest.x;
                            arm.pos.y = arm.rest.y;
                        }
                    }
                });

                headBob.v += (-headBob.y * 28) * dt;
                headBob.v *= Math.pow(0.01, dt);
                headBob.y += headBob.v * dt;
                headBob.y = clamp(headBob.y, -18, 18);

                const heldKeyCount = Array.from(pressed.values()).filter(t => t.type === "key" && t.held).length;
                const mouseHeld = activeMouseHeld() ? 1 : 0;
                const activity = clamp(((armL.impact + armR.impact) * 0.55) + heldKeyCount * 0.09 + mouseHeld * 0.20, 0, 1.3);
                updateSkin(dt, activity);

                if (!debugOn) return;
                debugTicker += dt;
                if (debugTicker < 0.12) return;
                debugTicker = 0;

                const active = currentSkinDef();
                const keyHeld = Array.from(pressed.values()).filter((t) => t.type === "key" && t.held).length;
                const mouseButtons = [
                    mTargets?.left?.held ? "L" : "-",
                    mTargets?.middle?.held ? "M" : "-",
                    mTargets?.right?.held ? "R" : "-"
                ].join("");
                const fmtArm = (name, arm) => {
                    if (!arm) return `${name}: n/a`;
                    const tgt = arm.assignedId || "-";
                    return `${name}: ${arm.phase} tgt=${tgt} impact=${arm.impact.toFixed(2)}`;
                };

                let assetLine = "asset: procedural";
                if (active.mode === "asset") {
                    const st = getInspectorState(active);
                    const loadedCount = Object.keys(st.images).length;
                    const expectedCount = st.visibleSet ? st.visibleSet.size : 0;
                    assetLine = `asset: ${active.id} loaded=${loadedCount}/${expectedCount} failed=${st.failed.length}`;
                }

                debugText.textContent =
                    `fps: ${fpsSmoothed.toFixed(1)}\n` +
                    `skin: ${skinState.activeId} -> ${skinState.targetId} mode=${active.mode || "procedural"}\n` +
                    `skeleton: ${skeletonOn ? "on" : "off"}\n` +
                    `semantic labels: ${semanticOn ? "on" : "off"}\n` +
                    `${assetLine}\n` +
                    `mouse: x=${mouseCenter.x.toFixed(1)} y=${mouseCenter.y.toFixed(1)} btn=${mouseButtons} moveTimer=${mouseMoveTimer.toFixed(2)}\n` +
                    `inputs: keysHeld=${keyHeld} pressedTargets=${Array.from(pressed.values()).filter(t => t.held).length}\n` +
                    `${fmtArm("armL", armL)}\n` +
                    `${fmtArm("armR", armR)}\n` +
                    `typing: ${isTyping() ? "yes" : "no"} activeEl=${document.activeElement?.id || document.activeElement?.tagName || "?"}`;
            }

            function draw() {
                const LAYOUT = layout();
                const { w, h } = LAYOUT;

                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = "rgba(0,0,0,0.08)";
                ctx.fillRect(0, 0, w, h);

                drawHead(LAYOUT);
                drawDesk(LAYOUT);
                drawKeyboard(LAYOUT);
                drawMouse(LAYOUT);
                drawSkeletonOverlay(LAYOUT);

                const active = currentSkinDef();
                const hideDefaultArms = !!(active.mode === "asset" && (
                    active.hideDefaultArms ||
                    (getAssetSkinState(active)?.visibleSet && (
                        getAssetSkinState(active).visibleSet.has("charLeftArmDownFill") ||
                        getAssetSkinState(active).visibleSet.has("charLeftArmDownLine") ||
                        getAssetSkinState(active).visibleSet.has("charLeftArmUpFill") ||
                        getAssetSkinState(active).visibleSet.has("charLeftArmUpLine") ||
                        getAssetSkinState(active).visibleSet.has("charRightArmDownFill") ||
                        getAssetSkinState(active).visibleSet.has("charRightArmDownLine") ||
                        getAssetSkinState(active).visibleSet.has("charRightArmUpFill") ||
                        getAssetSkinState(active).visibleSet.has("charRightArmUpLine")
                    ))
                ));
                if (!hideDefaultArms) {
                    drawArm(armL);
                    drawArm(armR);
                }
            }

            function loop(now) {
                const dt = Math.min(0.033, (now - lastTime) / 1000);
                lastTime = now;
                const fps = 1 / Math.max(dt, 0.0001);
                fpsSmoothed = lerp(fpsSmoothed, fps, 0.12);
                update(dt);
                draw();
                requestAnimationFrame(loop);
            }

            function populateCharacterSelect() {
                const fillSelect = (el) => {
                    el.innerHTML = "";
                    Object.entries(skinLibrary).forEach(([id, def]) => {
                        const opt = document.createElement("option");
                        opt.value = id;
                        opt.textContent = def.label;
                        el.appendChild(opt);
                    });
                };
                fillSelect(charSelect);
                fillSelect(editorSkinSelect);
            }

            function syncSkinSelects(id) {
                if (charSelect.value !== id) charSelect.value = id;
                if (editorSkinSelect.value !== id) editorSkinSelect.value = id;
            }

            // ===== INIT
            async function init() {
                resize();
                const LAYOUT = layout();
                setPanelSide(panelSide);
                openPanelWithTab("info");
                setInspectorPane(inspectorPane);
                debugText.style.display = debugOn ? "block" : "none";

                await loadManifestSkins();
                populateCharacterSelect();
                syncSkinSelects(skinState.activeId);
                charSelect.addEventListener("change", () => {
                    switchSkin(charSelect.value);
                    syncSkinSelects(charSelect.value);
                    refreshPartsInspector();
                });
                editorSkinSelect.addEventListener("change", () => {
                    switchSkin(editorSkinSelect.value);
                    syncSkinSelects(editorSkinSelect.value);
                    refreshPartsInspector();
                });
                refreshPartsInspector();

                keys = buildKeyRects(LAYOUT.keyboard);

                mousePad = LAYOUT.mousepad;
                mouseSize = LAYOUT.mouseSize;
                mouseCenter = {
                    x: mousePad.x + mousePad.w * 0.5,
                    y: mousePad.y + mousePad.h * 0.5
                };
                mTargets = mouseTargetsFromCenter(mouseCenter.x, mouseCenter.y, mouseSize);

                pressed.set("mouse_left", { id: "mouse_left", x: mTargets.left.x, y: mTargets.left.y, type: "mouse", held: false });
                pressed.set("mouse_right", { id: "mouse_right", x: mTargets.right.x, y: mTargets.right.y, type: "mouse", held: false });
                pressed.set("mouse_mid", { id: "mouse_mid", x: mTargets.middle.x, y: mTargets.middle.y, type: "mouse", held: false });

                armL = makeArm(LAYOUT.shoulderL, LAYOUT.restL);
                armR = makeArm(LAYOUT.shoulderR, LAYOUT.restR);

                window.addEventListener("resize", () => {
                    resize();
                    const L2 = layout();

                    keys = buildKeyRects(L2.keyboard);
                    mousePad = L2.mousepad;
                    mouseSize = L2.mouseSize;

                    const px = (mouseCenter.x - mousePad.x) / mousePad.w;
                    const py = (mouseCenter.y - mousePad.y) / mousePad.h;
                    mouseCenter = clampMouseToPad(
                        mousePad.x + mousePad.w * clamp(px, 0, 1),
                        mousePad.y + mousePad.h * clamp(py, 0, 1),
                        mousePad,
                        mouseSize
                    );
                    mTargets = mouseTargetsFromCenter(mouseCenter.x, mouseCenter.y, mouseSize);

                    pressed.get("mouse_left").x = mTargets.left.x; pressed.get("mouse_left").y = mTargets.left.y;
                    pressed.get("mouse_right").x = mTargets.right.x; pressed.get("mouse_right").y = mTargets.right.y;
                    pressed.get("mouse_mid").x = mTargets.middle.x; pressed.get("mouse_mid").y = mTargets.middle.y;

                    armL.shoulder = { ...L2.shoulderL };
                    armR.shoulder = { ...L2.shoulderR };
                    armL.rest = { ...L2.restL };
                    armR.rest = { ...L2.restR };

                    if (armL.phase === "idle") { armL.pos = { ...armL.rest }; }
                    if (armR.phase === "idle") { armR.pos = { ...armR.rest }; }
                });

                requestAnimationFrame((t) => { lastTime = t; loop(t); });
            }

            init();
        })();
    </script>

</body>

</html>
