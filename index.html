<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Desk Goblin Mash</title>
  <style>
    :root {
      --bg: #0f1116;
      --panel: #151a22;
      --text: #d6dde8;
      --muted: #8a94a7;
      --accent: #6ee7ff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100%;
    }
    header, footer {
      padding: 12px 14px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.0));
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    footer {
      border-top: 1px solid rgba(255,255,255,0.06);
      border-bottom: none;
      background: linear-gradient(to top, rgba(255,255,255,0.04), rgba(255,255,255,0.0));
    }
    header b { color: var(--accent); }
    .sub { color: var(--muted); font-size: 12px; margin-top: 4px; }
    #c {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(1200px 600px at 50% 20%, rgba(255,255,255,0.06), rgba(255,255,255,0.0)),
                  radial-gradient(900px 500px at 10% 80%, rgba(110,231,255,0.05), rgba(255,255,255,0.0));
    }
    .hint {
      display: flex; gap: 10px; flex-wrap: wrap; align-items: center;
      font-size: 12px; color: var(--muted);
    }
    .pill {
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      padding: 4px 8px;
      border-radius: 999px;
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div><b>Desk Goblin Mash</b> — press keys / click mouse</div>
    <div class="sub">Drop-in replaceable assets. Single HTML file for GitHub Pages.</div>
  </header>

  <canvas id="c"></canvas>

  <footer class="hint">
    <span class="pill">Keyboard: press anything</span>
    <span class="pill">Mouse: left / right / middle</span>
    <span class="pill">Tip: click canvas once if keys don’t register</span>
  </footer>
</div>

<script>
(() => {
  // =========================
  // 1) CONFIG: swap assets here
  // =========================
  const ASSETS = {
    // Later: replace these with real images (PNG/SVG).
    // If you want images: set enabled=true and provide src.
    imagesEnabled: false,
    head:   { src: "assets/head.png" },
    desk:   { src: "assets/desk.png" },
    hands:  { src: "assets/hands.png" },    // optional combined
    armL:   { src: "assets/arm_left.png" },
    armR:   { src: "assets/arm_right.png" },
    keyboard:{ src: "assets/keyboard.png" },
    mouse:  { src: "assets/mouse.png" }
  };

  // =========================
  // 2) CANVAS SETUP
  // =========================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const { clientWidth:w, clientHeight:h } = canvas;
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);

  // Ensure focus for key events
  canvas.tabIndex = 0;
  canvas.style.outline = "none";
  canvas.addEventListener("pointerdown", () => canvas.focus());

  // =========================
  // 3) SIMPLE TWEEN HELPERS
  // =========================
  const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
  const lerp  = (a,b,t) => a + (b-a)*t;

  // Aggressive smash curve: fast out, slightly overshoot, then spring back.
  function smashEase(t) {
    // t: 0..1
    // Piecewise: rush in (0..0.55), overshoot (0.55..0.75), return (0.75..1)
    if (t < 0.55) {
      const x = t / 0.55;
      // easeOutCubic
      return 1 - Math.pow(1 - x, 3);
    } else if (t < 0.75) {
      const x = (t - 0.55) / 0.20;
      // overshoot to 1.08
      return lerp(1.0, 1.08, 1 - Math.pow(1 - x, 2));
    } else {
      const x = (t - 0.75) / 0.25;
      // return back to 1.0
      return lerp(1.08, 1.0, 1 - Math.pow(1 - x, 2));
    }
  }

  // =========================
  // 4) VIRTUAL LAYOUT (positions)
  //    Everything scales with canvas size
  // =========================
  function layout() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    // Desk occupies lower 45% of screen
    const deskTopY = h * 0.55;

    // Keyboard block
    const kbW = w * 0.62;
    const kbH = h * 0.18;
    const kbX = (w - kbW) * 0.52; // slightly right
    const kbY = deskTopY + h * 0.08;

    // Mouse block
    const mouseW = w * 0.13;
    const mouseH = h * 0.16;
    const mouseX = kbX + kbW + w * 0.03;
    const mouseY = kbY + kbH * 0.10;

    // Character head peeking above desk
    const headW = w * 0.22;
    const headH = headW * 0.95;
    const headX = w * 0.34 - headW * 0.5;
    const headY = deskTopY - headH * 0.82;

    // Hand "rest" origins (where hands start)
    const restL = { x: w * 0.33, y: deskTopY + h * 0.03 };
    const restR = { x: w * 0.42, y: deskTopY + h * 0.03 };

    return {
      w, h,
      deskTopY,
      keyboard: { x: kbX, y: kbY, w: kbW, h: kbH },
      mouse:    { x: mouseX, y: mouseY, w: mouseW, h: mouseH },
      head:     { x: headX, y: headY, w: headW, h: headH },
      restL, restR
    };
  }

  // =========================
  // 5) KEY MAP: define keyboard keys + positions
  //    This is a "cartoon" keyboard: enough to look believable.
  // =========================
  function buildKeyRects(kb) {
    const keys = [];

    // Rows with relative key counts/sizes (simple)
    const rows = [
      // row, y, height, keys: [label, widthUnits]
      { y: 0.10, h: 0.22, items: [["ESC",1.2],["1",1],["2",1],["3",1],["4",1],["5",1],["6",1],["7",1],["8",1],["9",1],["0",1],["-",1],["=",1],["BKSP",1.7]] },
      { y: 0.34, h: 0.22, items: [["TAB",1.4],["Q",1],["W",1],["E",1],["R",1],["T",1],["Y",1],["U",1],["I",1],["O",1],["P",1],["[",1],["]",1],["\\",1.3]] },
      { y: 0.58, h: 0.22, items: [["CAPS",1.6],["A",1],["S",1],["D",1],["F",1],["G",1],["H",1],["J",1],["K",1],["L",1],[";",1],["'",1],["ENTER",2.0]] },
      { y: 0.82, h: 0.22, items: [["SHIFT",2.2],["Z",1],["X",1],["C",1],["V",1],["B",1],["N",1],["M",1], [",",1],[".",1],["/",1],["SHIFT",2.2]] },
    ];

    const padX = kb.w * 0.04;
    const padY = kb.h * 0.10;
    const innerW = kb.w - padX * 2;
    const innerH = kb.h - padY * 2;

    rows.forEach((row, rIdx) => {
      const totalUnits = row.items.reduce((s,it)=>s+it[1],0);
      const gap = innerW * 0.008;
      const unitW = (innerW - gap * (row.items.length - 1)) / totalUnits;

      let x = kb.x + padX;
      const y = kb.y + padY + innerH * row.y - (innerH * row.h) * 0.5;
      const h = innerH * row.h;

      row.items.forEach(([label, units], i) => {
        const w = unitW * units;
        keys.push({
          id: `r${rIdx}_${i}_${label}`,
          label,
          x, y, w, h,
          press: 0 // 0..1
        });
        x += w + gap;
      });
    });

    // Add a spacebar row as a single big key (optional)
    keys.push({
      id: `space`,
      label: "SPACE",
      x: kb.x + kb.w*0.18,
      y: kb.y + kb.h*0.78,
      w: kb.w*0.44,
      h: kb.h*0.16,
      press: 0
    });

    return keys;
  }

  // For mapping actual key events to a "target key" on our cartoon keyboard:
  function chooseKeyForEvent(keys, e) {
    // Prefer letter keys, digits, space, enter, backspace, tab, shift, esc.
    const k = e.key;

    // Normalize
    const upper = (typeof k === "string") ? k.toUpperCase() : "";

    const special = {
      " ": "SPACE",
      "ENTER": "ENTER",
      "BACKSPACE": "BKSP",
      "TAB": "TAB",
      "SHIFT": "SHIFT",
      "ESCAPE": "ESC"
    };

    let wanted = special[upper] || special[k] || upper;

    // Single letters/digits/punct: map to same label if present
    // For non-matching keys, just pick a random key for comedy.
    let match = keys.find(x => x.label === wanted);
    if (!match && wanted.length === 1) {
      match = keys.find(x => x.label === wanted);
    }
    if (!match) {
      // If key is like "ArrowLeft" etc, pick WASD-ish keys for fun
      if (upper.includes("ARROW")) {
        const map = { "ARROWLEFT":"A", "ARROWRIGHT":"D", "ARROWUP":"W", "ARROWDOWN":"S" };
        const tryLabel = map[upper];
        match = keys.find(x => x.label === tryLabel) || null;
      }
    }
    if (!match) {
      match = keys[Math.floor(Math.random() * keys.length)];
    }
    return match;
  }

  // =========================
  // 6) ARM/SMASH STATE
  // =========================
  function makeArm(origin) {
    return {
      origin: { ...origin },
      pos:    { ...origin },
      target: { ...origin },
      active: false,
      t: 0,
      dur: 0.16,      // time to reach (seconds-ish)
      hold: 0.04,     // brief "impact" hold
      returnDur: 0.20,
      phase: "idle",  // "go" | "hold" | "return"
      // Visual squash/impact
      impact: 0,
    };
  }

  let L, R;
  let keyRects = [];
  let lastTime = performance.now();

  // Mouse buttons target zones on mouse
  function mouseTargets(mouseRect) {
    const { x,y,w,h } = mouseRect;
    return {
      left:   { x: x + w*0.30, y: y + h*0.32, r: Math.min(w,h)*0.12 },
      right:  { x: x + w*0.70, y: y + h*0.32, r: Math.min(w,h)*0.12 },
      middle: { x: x + w*0.50, y: y + h*0.30, r: Math.min(w,h)*0.10 },
    };
  }

  function retargetArmToPoint(point) {
    // Pick the closer arm for the target
    const dL = Math.hypot(point.x - L.origin.x, point.y - L.origin.y);
    const dR = Math.hypot(point.x - R.origin.x, point.y - R.origin.y);
    const arm = (dL <= dR) ? L : R;

    // Start smash
    arm.target = { ...point };
    arm.active = true;
    arm.t = 0;
    arm.phase = "go";
    arm.impact = 0;
  }

  function pressKeyRect(key) {
    key.press = 1;
  }

  // =========================
  // 7) INPUT
  // =========================
  window.addEventListener("keydown", (e) => {
    // Prevent page scrolling on space/arrow keys
    if ([" ", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) e.preventDefault();

    const key = chooseKeyForEvent(keyRects, e);
    const point = { x: key.x + key.w*0.5, y: key.y + key.h*0.5 };
    pressKeyRect(key);
    retargetArmToPoint(point);
  }, { passive:false });

  window.addEventListener("mousedown", (e) => {
    const LAYOUT = layout();
    const t = mouseTargets(LAYOUT.mouse);
    let point = null;
    if (e.button === 0) point = { x: t.left.x, y: t.left.y };
    if (e.button === 1) point = { x: t.middle.x, y: t.middle.y };
    if (e.button === 2) point = { x: t.right.x, y: t.right.y };
    if (!point) return;
    retargetArmToPoint(point);
  });

  // stop context menu so right click feels like interaction
  window.addEventListener("contextmenu", (e) => e.preventDefault());

  // =========================
  // 8) DRAWING (placeholder style)
  //    Replace these with image draws later.
  // =========================
  function roundRect(x,y,w,h,r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }

  function drawDesk(L) {
    const { w,h,deskTopY } = L;
    // desk front
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0, deskTopY, w, h - deskTopY);

    // desk top lip
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fillRect(0, deskTopY-3, w, 3);
  }

  function drawHead(L) {
    const { head } = L;
    // Placeholder chibi head (replace with image)
    ctx.save();
    ctx.translate(head.x, head.y);

    // head
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    roundRect(0, 0, head.w, head.h, head.w*0.35);
    ctx.fill();

    // eyes
    ctx.fillStyle = "rgba(255,255,255,0.45)";
    ctx.beginPath();
    ctx.ellipse(head.w*0.32, head.h*0.52, head.w*0.07, head.h*0.10, 0, 0, Math.PI*2);
    ctx.ellipse(head.w*0.68, head.h*0.52, head.w*0.07, head.h*0.10, 0, 0, Math.PI*2);
    ctx.fill();

    // blush
    ctx.fillStyle = "rgba(255,120,160,0.25)";
    ctx.beginPath();
    ctx.ellipse(head.w*0.22, head.h*0.65, head.w*0.08, head.h*0.04, 0, 0, Math.PI*2);
    ctx.ellipse(head.w*0.78, head.h*0.65, head.w*0.08, head.h*0.04, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawKeyboard(L) {
    const kb = L.keyboard;

    // base
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(kb.x, kb.y, kb.w, kb.h, kb.h*0.16);
    ctx.fill();

    // keys
    keyRects.forEach(k => {
      const press = clamp(k.press, 0, 1);
      const dy = press * (k.h * 0.18); // depression amount
      ctx.fillStyle = "rgba(255,255,255,0.07)";
      roundRect(k.x, k.y + dy, k.w, k.h, k.h*0.25);
      ctx.fill();

      // label (optional)
      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.font = `${Math.max(10, kb.h*0.10)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(k.label, k.x + k.w/2, k.y + dy + k.h/2);
    });
  }

  function drawMouse(L) {
    const m = L.mouse;
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(m.x, m.y, m.w, m.h, m.w*0.45);
    ctx.fill();

    const t = mouseTargets(m);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.beginPath();
    ctx.ellipse(t.left.x, t.left.y, t.left.r*1.25, t.left.r, 0, 0, Math.PI*2);
    ctx.ellipse(t.right.x, t.right.y, t.right.r*1.25, t.right.r, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.beginPath();
    ctx.ellipse(t.middle.x, t.middle.y, t.middle.r*0.8, t.middle.r*1.2, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function drawArm(arm) {
    // Simple stretchy arm: line + hand blob
    const ox = arm.origin.x, oy = arm.origin.y;
    const px = arm.pos.x, py = arm.pos.y;

    const dx = px - ox, dy = py - oy;
    const dist = Math.hypot(dx, dy) || 1;
    const nx = dx / dist, ny = dy / dist;

    // thickness scales a bit with impact
    const th = 10 + arm.impact * 8;

    // arm
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = th;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(px - nx*10, py - ny*10);
    ctx.stroke();

    // hand
    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.beginPath();
    ctx.ellipse(px, py, 18 + arm.impact*6, 14 - arm.impact*3, Math.atan2(dy, dx), 0, Math.PI*2);
    ctx.fill();

    // tiny "slam spark"
    if (arm.impact > 0.6) {
      ctx.strokeStyle = "rgba(110,231,255,0.28)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px + 8, py - 10);
      ctx.lineTo(px + 18, py - 18);
      ctx.moveTo(px - 6, py - 12);
      ctx.lineTo(px - 14, py - 22);
      ctx.stroke();
    }
  }

  // =========================
  // 9) UPDATE LOOP
  // =========================
  function update(dt) {
    // key rebound
    keyRects.forEach(k => {
      // decay press
      k.press = Math.max(0, k.press - dt * 6.5);
    });

    // arm state machines
    [L, R].forEach(arm => {
      if (!arm.active) {
        arm.pos.x = lerp(arm.pos.x, arm.origin.x, 1 - Math.pow(0.001, dt));
        arm.pos.y = lerp(arm.pos.y, arm.origin.y, 1 - Math.pow(0.001, dt));
        arm.impact = Math.max(0, arm.impact - dt * 8);
        return;
      }

      if (arm.phase === "go") {
        arm.t += dt;
        const t = clamp(arm.t / arm.dur, 0, 1);
        const s = smashEase(t);

        arm.pos.x = lerp(arm.origin.x, arm.target.x, s);
        arm.pos.y = lerp(arm.origin.y, arm.target.y, s);

        // ramp impact up near the end
        arm.impact = Math.max(arm.impact, t);

        if (t >= 1) {
          arm.phase = "hold";
          arm.t = 0;
          arm.impact = 1;
        }
      } else if (arm.phase === "hold") {
        arm.t += dt;
        // keep impact
        arm.impact = 1;
        if (arm.t >= arm.hold) {
          arm.phase = "return";
          arm.t = 0;
        }
      } else if (arm.phase === "return") {
        arm.t += dt;
        const t = clamp(arm.t / arm.returnDur, 0, 1);
        // easeOutQuad back
        const s = 1 - (1 - t) * (1 - t);

        arm.pos.x = lerp(arm.target.x, arm.origin.x, s);
        arm.pos.y = lerp(arm.target.y, arm.origin.y, s);

        arm.impact = Math.max(0, 1 - t*1.2);

        if (t >= 1) {
          arm.active = false;
          arm.phase = "idle";
          arm.impact = 0;
          arm.pos.x = arm.origin.x;
          arm.pos.y = arm.origin.y;
        }
      }
    });
  }

  function draw() {
    const LAYOUT = layout();
    const { w,h } = LAYOUT;

    ctx.clearRect(0,0,w,h);

    // Background
    // (Already in canvas CSS, but you can add subtle overlays)
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.fillRect(0,0,w,h);

    // Scene layers:
    // 1) head behind desk
    drawHead(LAYOUT);

    // 2) desk
    drawDesk(LAYOUT);

    // 3) keyboard + mouse
    drawKeyboard(LAYOUT);
    drawMouse(LAYOUT);

    // 4) arms/hands on top
    drawArm(L);
    drawArm(R);

    // Optional debug crosshair for last target
    // ctx.fillStyle="rgba(110,231,255,0.4)"; ctx.fillRect(L.target?.x-2,L.target?.y-2,4,4);
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - lastTime) / 1000);
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // =========================
  // 10) INIT
  // =========================
  function init() {
    resize();
    const LAYOUT = layout();

    // build keys and arms
    keyRects = buildKeyRects(LAYOUT.keyboard);
    L = makeArm(LAYOUT.restL);
    R = makeArm(LAYOUT.restR);

    // keep origins responsive on resize
    window.addEventListener("resize", () => {
      const L2 = layout();
      // Rebuild key positions for new size
      keyRects = buildKeyRects(L2.keyboard);

      // Update arm origins smoothly
      L.origin = { ...L2.restL };
      R.origin = { ...L2.restR };
      // If idle, snap to origin
      if (!L.active) L.pos = { ...L.origin };
      if (!R.active) R.pos = { ...R.origin };
    });

    requestAnimationFrame((t)=>{ lastTime = t; loop(t); });
  }

  init();
})();
</script>
</body>
</html>
